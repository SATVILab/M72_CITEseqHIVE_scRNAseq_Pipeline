---
title: "CITEseq-HIVE Seurat Cluster and ID cell types with Multimodal Data - Full Dataset"
format:
  html:
        code-fold: true
editor: visual
---

## Description

This script takes the output of CITEseqHIVE_Seurat_FilterMergeQC.qmd as input. Each Assay ("RNA", and "ADT") will be processed individually first, and then integrated using Weighted Nearest Neighbors (WNN) for combined analysis. Analysis in this script includes normalization and scaling, clustering, and cell type identification.

### Clear console

```{r, output = FALSE}
ls()
rm(list=ls())
```

### Set output directory

```{r}
dir_save <- "output/dataset_full/"
```

### Load libraries

```{r, message = FALSE, warning = FALSE}
library(SingleCellExperiment)
library(Seurat)
library(SeuratObject)
library(tidyr)
library(dplyr)
library(clustree)
library(ggpubr)
library(patchwork)
library(reshape2)
library(RColorBrewer)
library(magrittr)
library(HGNChelper)
library(openxlsx)
library(multtest)
library(metap)
library(ggplot2)
library(cowplot)
library(readxl)
library(devtools)
library(presto)
library(kableExtra)
library(glue)
```

## RNA

Begin by processing the "RNA" assay. In the below section, only RNA expression data will be considered when performing normalization, scaling, clustering, and cell identification steps. ADT data is ignored.

### Load the filtered, merged, .Rdata object and examine structure

The Seurat_FilterMerge_obj.Rdata file generated by CITEseqHIVE_Seurat_FilterMergeQC.qmd serves as input for this pipeline. It should contain only one object, called "obj" which is the filtered and merged Seruat object for all SMARTseq2 plates.

```{r}
load("output/dataset_full/Seurat_FilterMerge_obj.Rdata")
obj

# Confirm Seruat object contains assays for RNA and ADT
Assays(obj)
```

### Split the object into multiple layers for integration based on the RNA Assay

Integration is performed to account for batch effects. Therefore, the factor used to split the object into multiple layers should be the factor that provides information on which batch the samples came from. In this case, each batch has a unique RUN ID. The metadata column for that contains the RUN IDs is called "RUN" and should be used to integrate layers.

Because this Seurat object contains RNA, HTO, and ADT assays, we will perform integration separately beginning with the RNA assay.

```{r, warning = FALSE}
obj[["RNA"]] <- split(obj[["RNA"]], f = obj$RUN)
obj
```

### Show QC metrics for the first 5 cells and create a metadata object

This is intended to give a snapshot look at some QC metrics and metadata features that can be used for downstream analysis.

```{r}
head(obj@meta.data, 5) %>% 
  kbl() %>% 
  kable_styling()

metadata <- obj@meta.data
```

### Normalize the RNA data

As this dataset contains only an RNA assay we use standard Seurat NormalizeData function to perform log normalization with a scale factor of 10000.

```{r, message = FALSE}
# Consider changing to SCTransform 
obj <- NormalizeData(obj, normalization.method = "LogNormalize", scale.factor = 10000) 
```

### Identify variable features

We select the top 2000 variable features for downstream analyses using the standard Seurat FindVariableFeatures function with selection method "vst".

```{r, message = FALSE, warning = FALSE}
# Calculate the top 2000 highly variable features
obj <- FindVariableFeatures(obj, selection.method = "vst", nfeatures = 2000) 

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(obj), 10)

# plot variable features and label top 10 variable features
plot1 <- VariableFeaturePlot(obj)
plot2 <-LabelPoints(plot = plot1, points = top10, repel = TRUE)
```

```{r, echo = FALSE, warning = FALSE}
print(plot2)
```

### Scale the RNA data

Data is scaled using only variable features by default.

```{r, message = FALSE}
# Use defaults to scale only variable features 
obj <- ScaleData(obj) 
```

### Perform linear dimensional reduction

Principal component analysis (PCA) is used for linear dimensional reduction of scaled data. PCA is run with default options. The plots below visualize dimensional reduction genes for principal components (PC) 1 and 2, display cell positioning in 2D, and a heatmap of genes associated with the top 1 and 15 PCs for all cells.

```{r, output = FALSE}
# Perform PCA for linear dimensional reduction on scaled data
obj <- RunPCA(obj, features = NULL) 

# Examine and visualize PCA results a few different ways

plot1 <- VizDimLoadings(obj, dims = 1:2, reduction = "pca")

plot2 <- DimPlot(obj, reduction = "pca") + NoLegend()

plot3 <- DimHeatmap(obj, dims = 1, cells = 500, balanced = TRUE)

plot4 <- DimHeatmap(obj, dims = 1:15, cells = 500, balanced = TRUE)
```

```{r, echo = FALSE}
print(plot1)
print(plot2)
DimHeatmap(obj, dims = 1, cells = 500, balanced = TRUE)
```

```{r, echo = FALSE}
#| fig-height: 19.5
DimHeatmap(object = obj, dims = 1:15, cells = 500, balanced = TRUE) 
```

### Examine variance explained by each principal component

Here we look at the variance in the dataset that is explained by each individual PC and at the cumulative variance explained by the PCs.

We also determine the dimensionality of the dataset using an Elbow plot (more efficient alternative to JackStraw procedure).

```{r}
pca = obj[["pca"]]

# Get the eigenvalues
evs = pca@stdev^2
total.var = pca@misc$total.variance
varExplained = evs/total.var
pca.data = data.frame(PC=factor(1:length(evs)),
                      percVar=varExplained*100)
pca.data$cumulVar = cumsum(pca.data$percVar)

head(pca.data, 20)

scPlot1 <- pca.data[1:10,] %>%
          ggplot(aes(x=PC, y=percVar)) +
          geom_bar(stat='identity') +
          geom_hline(yintercept = 1, colour="red", linetype=3) +
          labs(title="Variance Explanation by PCA") +
          xlab("Principal Components") +
          ylab("Percentage of Explained Variance") +
          theme_bw()

scPlot2 <- pca.data[1:10,] %>%
          ggplot(aes(x=PC, y=cumulVar)) +
          geom_bar(stat='identity') +
          geom_hline(yintercept = 50, colour="red", linetype=3) +
          labs(title="Cumulative Variance Explanation by PCA") +
          xlab("Principal Components") +
          ylab("Cumulative Percentage of Explained Variance") +
          theme_bw()

elbow <- ElbowPlot(obj)
```

```{r, echo = FALSE}
print(scPlot1)
print(scPlot2)
print(elbow)
```

### Cluster cells based on RNA

Start with standard Seurat clustering method WITHOUT INTEGRATION. Use the bar and Elbow plots to determine minimum dimensions to use for clustering. Clustering is performed using UMAP for non-linear dimensional reduction. The number of dimensions is set to 30. PCA is used to find neighbors and clusters and for UMAP reduction.

The tabulated plots visualize the basic UMAP with seurat clusters for all cells and conditions as well as UMAPs grouped by metadata features and split by group.

```{r, message = FALSE, warning = FALSE}
obj <- FindNeighbors(obj, reduction = "pca")
obj <- FindClusters(obj, cluster.name = "unintegrated_clusters")
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca", reduction.name = "umap.unintegrated")

plot1 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("seurat_clusters"), split.by = "group")
plot2 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("RUN", "seurat_clusters"), split.by = "group")
plot3 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("STIM", "seurat_clusters"), split.by = "group")
plot4 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("PID", "seurat_clusters"), split.by = "group")
plot5 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("VISIT", "seurat_clusters"), split.by = "group")
plot6 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

::: panel-tabset
## UMAP group

```{r, echo = FALSE}
print(plot1)
```

## UMAP RUN

```{r, echo = FALSE}
#| fig-height: 10
print(plot2)
```

## UMAP STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot3)
```

## UMAP PID

```{r, echo = FALSE}
#| fig-height: 10
print(plot4)
```

## UMAP VISIT

```{r, echo = FALSE}
#| fig-height: 10
print(plot5)
```

## UMAP VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot6)
```
:::

### Inspect cluster proportions on unintegrated clusters

Next we examine the proportion of each cluster that is comprised of cells with key metadata features: RUN, group, STIM, PID, and VISIT. Proportions are shown alongside total cell number per cluster.

```{r, warning = FALSE, message = FALSE}
plot_integrated_clusters = function (srat, batchcolumn) {
  ## take an integrated Seurat object, plot distributions over orig.ident

  count_table <- table(srat@meta.data$seurat_clusters, srat@meta.data[[batchcolumn]])
  count_mtx   <- as.data.frame.matrix(count_table)
  count_mtx$cluster <- rownames(count_mtx)
  melt_mtx    <- melt(count_mtx)
  melt_mtx$cluster <- as.factor(melt_mtx$cluster)

  cluster_size   <- aggregate(value ~ cluster, data = melt_mtx, FUN = sum)

  sorted_labels <- paste(sort(as.integer(levels(cluster_size$cluster)),decreasing = T))
  cluster_size$cluster <- factor(cluster_size$cluster,levels = sorted_labels)
  melt_mtx$cluster <- factor(melt_mtx$cluster,levels = sorted_labels)

  colnames(melt_mtx)[2] <- "dataset"


  p1 <- ggplot(cluster_size, aes(y= cluster,x = value)) + geom_bar(position="dodge", stat="identity",fill = "grey60") +
    theme_bw() + scale_x_log10() + xlab("Cells per cluster, log10 scale") + ylab("")
  p2 <- ggplot(melt_mtx,aes(x=cluster,y=value,fill=dataset)) +
    geom_bar(position="fill", stat="identity") + theme_bw() + coord_flip() +
    #scale_fill_brewer(palette = "Set2") +
    ylab("Fraction of cells in each dataset") + xlab("Cluster number") + theme(legend.position="top")

  p2 + p1 + plot_layout(widths = c(3,1))
}


plot1 <- plot_integrated_clusters(obj, 'group')
plot2 <- plot_integrated_clusters(obj, 'RUN')
plot3 <- plot_integrated_clusters(obj, 'STIM')
plot4 <- plot_integrated_clusters(obj, 'PID')
plot5 <- plot_integrated_clusters(obj, 'VISIT')
plot6 <- plot_integrated_clusters(obj, 'VISIT_STIM')
```

::: panel-tabset
## Proportions group

```{r, echo = FALSE}
print(plot1)
```

## Proportions RUN

```{r, echo = FALSE}
print(plot2)
```

## Proportions STIM

```{r, echo = FALSE}
print(plot3)
```

## Proportions PID

```{r, echo = FALSE}
print(plot4)
```

## Proportions VISIT

```{r, echo = FALSE}
print(plot5)
```

## Proportions VISIT & STIM

```{r, echo = FALSE}
print(plot6)
```
:::

### Perform integration of RNA Assay

Integration is performed using the RUN metadata variable. Each RUN is representative of a single experimental processing batch which includes samples from two PIDs at both time points. Each RUN therefore can be seen as an individual batch and can be used in integration to adjust for experimentally-introduced batch effects.

```{r, message = FALSE, warning = FALSE}
obj <- IntegrateLayers(object = obj, 
                       method = CCAIntegration, 
                       orig.reduction = "pca", 
                       new.reduction = "integrated.cca", 
                       verbose = FALSE)

obj[["RNA"]] <- JoinLayers(obj[["RNA"]])
```

### Save integrated Seurat object as Rdata and rds

```{r}
save(obj, file = paste0(dir_save, "Seurat_ClusterIDCells_obj_IntegratedIntermediate.Rdata"))
saveRDS(obj, file = paste0(dir_save, "Seurat_ClusterIDcells_obj_IntegratedIntermediate.rds"))
```

### Cluster integrated object and plot

```{r}
obj <- FindNeighbors(obj, reduction = "integrated.cca", dims = 1:30) 
obj <- FindClusters(obj, resolution = 1.2)

obj <- RunUMAP(obj, dims = 1:30, reduction = "integrated.cca") 

plot1 <- DimPlot(obj, reduction = "umap", group.by = c("seurat_clusters"), split.by = "group")
plot2 <- DimPlot(obj, reduction = "umap", group.by = c("STIM", "seurat_clusters"), split.by = "group")
plot3 <- DimPlot(obj, reduction = "umap", group.by = c("PID", "seurat_clusters"), split.by = "group")
plot4 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT", "seurat_clusters"), split.by = "group")
plot5 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

::: panel-tabset
## UMAP group

```{r, echo = FALSE}
print(plot1)
```

## UMAP RUN

```{r, echo = FALSE}
#| fig-height: 10

print(plot2)
```

## UMAP PID

```{r, echo = FALSE}
#| fig-height: 10

print(plot3)
```

## UMAP VISIT

```{r, echo = FALSE}
#| fig-height: 10

print(plot4)
```

## UMAP VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10

print(plot5)
```
:::

### Inspect RUN metrics on integrated clusters

Now that integration is complete, we will re-examine the proportion of each cluster that is comprised of cells with key metadata features: RUN, group, PID, VISIT, and STIM. Proportions are shown alongside total cell number per cluster. Compare these outputs to those above for unintegrated clusters to determine how cluster composition was changed by integration.

```{r}
plot1 <- plot_integrated_clusters(obj, 'group')
plot2 <- plot_integrated_clusters(obj, 'RUN')
plot3 <- plot_integrated_clusters(obj, 'STIM')
plot4 <- plot_integrated_clusters(obj, 'PID')
plot5 <- plot_integrated_clusters(obj, 'VISIT')
plot6 <- plot_integrated_clusters(obj, 'VISIT_STIM')
```

::: panel-tabset
## Proportions group

```{r, echo = FALSE}
print(plot1)
```

## Proportions RUN

```{r, echo = FALSE}
print(plot2)
```

## Proportions STIM

```{r, echo = FALSE}
print(plot3)
```

## Proportions PID

```{r, echo = FALSE}
print(plot4)
```

## Proportions VISIT

```{r, echo = FALSE}
print(plot5)
```

## Proportions VISIT & STIM

```{r, echo = FALSE}
print(plot6)
```
:::

### Determine more accurate cluster resolution using clustree

Iterating through different resolutions using the clustree package can help determine what resolution best fits the data so that it can be used for downstream analyses. Using clustree, we iterate the clustering algorithm over a resolution range of 0.2 - 2, increasing by 0.2 with each round. We then plot the UMAPs for a representative selection of these iterations to determine what resolution to select moving forward.

```{r, message = FALSE, output = FALSE}
#| fig-height: 13

resolution.range <- seq(from =0.2, to = 2, by = 0.2)
obj <- Seurat::FindClusters(object = obj, resolution = resolution.range)

clustree <- clustree(obj, prefix = "RNA_snn_res.")

pdf(paste0(dir_save, "clustree.all.pdf"))
clustree_plot <- clustree
print(clustree_plot)
invisible(dev.off())
clustree_plot

umap.0.4 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.0.4")
umap.0.6 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.0.6")
umap.0.8 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.0.8")
umap.1 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.1")
umap.1.2 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.1.2")

snn_all <- (umap.0.4 | umap.0.6) / (umap.0.8 | umap.1) / umap.1.2

pdf(paste0(dir_save, "umap_snn_compare.pdf"), width = 20, height = 20)
snn_all
invisible(dev.off())
```

```{r, echo = FALSE}
#| fig-height: 13

print(snn_all)
```

### Visualize clusters

Based on the clustree analysis, the optimal resolution for this dataset is 1.2.We set cluster identities to those associated with resolution = 1.2 and use these identities for further analysis.

```{r, message=FALSE, warning = FALSE}
# Select which resolution to use based on clustree analysis and assign optimal cluster IDs to Idents
Idents(object = obj) <- "RNA_snn_res.0.6"

# Plot UMAP
pdf(paste0(dir_save, "umap_res.clustree.pdf"))
plot1 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
print(plot1)
invisible(dev.off())

# Plot Feature plot to ensure clustering is not driven by QC artifacts
pdf(paste0(dir_save, "umap_res.clustree_QC.pdf"))
QC_feature <- FeaturePlot(obj, features = c("nCount_RNA", "nFeature_RNA", "percent.mito", "Complexity"))
print(QC_feature)
invisible(dev.off())
```

```{r, echo = FALSE}
print(plot1)
print(QC_feature)
```

To explore how clustering differs for various metadata features, we plot the optimized UMAP and group and split by features of interest.

```{r}
pdf(paste0(dir_save, "umap_allRUN_res.clustree.pdf"), height = 6, width = 25)
plot1 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "RUN",
        repel = T,
        ncol = 2)
print(plot1)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allHIVES_res.clustree.pdf"), height = 6, width = 25)
plot2 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "HIVE",
        repel = T,
        ncol = 2)
print(plot2)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allPID_res.clustree.pdf"), height = 6, width = 25)
plot3 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "PID",
        repel = T, 
        ncol = 2)
print(plot3)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allSTIM_res.clustree.pdf"), height = 6, width = 20)
plot4 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "STIM",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot4)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allVISIT_res.clustree.pdf"), height = 6, width = 20)
plot5 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "VISIT",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot5)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allConditions_res.clustree.pdf"), height = 12, width = 20)
plot6 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = c("group", "STIM"),
        split.by = "VISIT",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot6)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allConditionsAlternative_res.clustree.pdf"), height = 12, width = 10)
plot7 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = c("VISIT", "STIM"),
        split.by = "group",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot7)
invisible(dev.off())
```

::: panel-tabset
## RUN

```{r, echo = FALSE}
#| fig-height: 19

print(plot1)
```

## HIVEs

```{r, echo = FALSE}
#| fig-height: 19

print(plot2)
```

## PID

```{r, echo = FALSE}
#| fig-height: 32

print(plot3)
```

## STIM

```{r, echo = FALSE}
print(plot4)
```

## VISIT

```{r, echo = FALSE}
print(plot5)
```

## PID & VISIT

```{r, echo = FALSE}
#| fig-height: 9.5

print(plot6)
```

## PID & VISIT Alternative

```{r, echo = FALSE}
#| fig-height: 9.5

print(plot7)
```
:::

### Determine marker expression by cluster

Find markers for every cell cluster compared to all remaining cells, report only the positive ones. Save a .csv file that contains the markers for each cluster.

```{r, message = FALSE, output = FALSE}
obj.markers <- FindAllMarkers(obj, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)

obj.markers %>%
  group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1)

write.csv(obj.markers, file = file.path(dir_save, "all_markers_snn.clustree.csv"), quote = FALSE)
```

### Examine differential expression in clusters

Identify markers differentially expressed between specific clusters of interest and plot differentially expressed features as relative expression and as counts.

```{r, message = FALSE, warning = FALSE}
# Function to create relative expression violin plots 
create_vln_rel <- function(obj) {

  # Plot expression of top 10 differentially expressed genes for the current cluster
   vln_plot_rel <- VlnPlot(obj,
          features = rownames(cluster.markers)[1:10],
          ncol = 2,
          pt.size = 0)
  vln_plot_relexp <- paste0("DEG_VlnPlotRelExp_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, vln_plot_relexp), height = 12, width = 6)
  print(vln_plot_rel)
  dev.off()

  return(vln_plot_rel)

}

# Function to create counts violin plots
create_vln_cnt <- function(obj) {

  vln_plot_cnt <- VlnPlot(obj,
          features = rownames(cluster.markers)[1:10],
          slot = "counts", 
          log = TRUE, 
          ncol = 2,
          pt.size = 0)
  vln_plot_counts <- paste0("DEG_VlnPlotCounts_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, vln_plot_counts), height = 12, width = 6)
  print(vln_plot_cnt)
  dev.off()

  return(vln_plot_cnt)

}

# Function to create feature plots
create_feature <- function(obj) {

    feature_plot <- FeaturePlot(obj,
            features = rownames(cluster.markers)[1:10], 
            label = TRUE,
            label.size = 4,
            split.by = "group",
            ncol = 2,
            pt.size = 0)
  feature_plots <- paste0("DEG_FeaturePlot_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, feature_plots), height = 24, width = 6)
  print(feature_plot)
  dev.off()

  return(feature_plot)

}

# List to store relative expression violin plots
vln_plot_rel_list <- list()

# List to store counts violin plots
vln_plot_cnt_list <- list()

# List to store feature plots
feature_plot_list <- list()

# Create a list of all cluster identities in obj
cluster.ids <- levels(Idents(obj))

# Initialize a list to store cluster markers
cluster.markers <- list()

# Loop through each Seurat cluster in obj
for (cluster.id in cluster.ids) {
  
  # Find markers for the current cluster
  cluster.markers <- FindMarkers(obj, ident.1 = cluster.id)
  
  # Assign a dynamic object name based on the cluster ID
  object.name <- paste0("cluster.markers.", cluster.id)
  
  # Export cluster markers to a CSV file
  csv_file <- paste0(object.name, ".csv")
  write.csv(cluster.markers, file = file.path(dir_save, paste0(csv_file)), row.names = TRUE)
  
  # Create plots using functions
  vln_plot_rel <- create_vln_rel(obj)
  vln_plot_cnt <- create_vln_cnt(obj)
  feature_plot <- create_feature(obj)


  # Assign the plots to a variable with a dynamic name
  assign(paste0("VlnPlotRel_", cluster.id), vln_plot_rel)
  assign(paste0("VlnPlotCnt_", cluster.id), vln_plot_cnt)
  assign(paste0("FeaturePlot_", cluster.id), feature_plot)

  # Add the plots to the associated list
  vln_plot_rel_list[[cluster.id]] <- vln_plot_rel
  vln_plot_cnt_list[[cluster.id]] <- vln_plot_cnt
  feature_plot_list[[cluster.id]] <- feature_plot
  
}

# Plot a heatmap to look at the top 10 differentially expressed genes across all clusters
pdf(paste0(dir_save, "DEG_Heatmap_AllClusters_Top10.pdf"), height = 30, width = 20)
obj.markers %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC) -> top10
plot1 <- DoHeatmap(obj, features = top10$gene) + NoLegend()
invisible(dev.off())

# Find all markers distinguishing an interesting cluster from main PBMC clusters
InterestClustervOthers.markers <- FindMarkers(obj, ident.1 = 4, ident.2 = c(0:3))
```

Plot top 10 differentially expressed genes per cluster as relative expression.

::: panel-tabset
```{r}
#| fig-height: 25.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(vln_plot_rel_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(vln_plot_rel_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Plot top 10 differentially expressed genes per cluster as counts.

::: panel-tabset
```{r}
#| fig-height: 25.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(vln_plot_cnt_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(vln_plot_cnt_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Plot top 10 differentially expressed genes per cluster as feature plots.

::: panel-tabset
```{r}
#| fig-height: 32.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(feature_plot_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(feature_plot_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Examine top 10 features that distinguish each cluster as a heatmap and print the top 10 markers that distinguish a cluster of interest from all others. In this case, we look at the markers that distinguish cluster 4 from all others.

```{r, echo = FALSE, warning = FALSE}
DoHeatmap(obj, features = top10$gene) + NoLegend()
head(InterestClustervOthers.markers, n = 10)
```

Visualize expression of sorting panel markers on clusters.

```{r, message=FALSE}
#| fig-height: 13

########### ADD.NOISE CHANGE MADE HERE #############

# Plot expression of the sorting panel markers 
vln_plot_rel <- VlnPlot(obj,
        features = c("CD3G", "CD4", "CD8A", "CD69", "CD40LG", "TNFRSF9"),
        ncol = 2,
        pt.size = 0,
        add.noise = FALSE)
vln_plot_relexp <- paste0("DEG_VlnPlotRelExp_SortingPanel.pdf")
pdf(paste0(dir_save, vln_plot_relexp), height = 12, width = 6)
print(vln_plot_rel)
invisible(dev.off())

vln_plot_cnt <- VlnPlot(obj,
        features = c("CD3G", "CD4", "CD8A", "CD69", "CD40LG", "TNFRSF9"),
        slot = "counts", 
        log = TRUE, 
        ncol = 2,
        pt.size = 0,
        add.noise = FALSE)
vln_plot_counts <- paste0("DEG_VlnPlotCounts_SortingPanel.pdf")
pdf(paste0(dir_save, vln_plot_counts), height = 12, width = 6)
print(vln_plot_cnt)
invisible(dev.off())

feature_plot <- FeaturePlot(obj,
          features = c("CD3G", "CD4", "CD8A", "CD69", "CD40LG", "TNFRSF9"), 
          label = TRUE,
          label.size = 4,
          split.by = "group",
          pt.size = 0)
feature_plots <- paste0("DEG_FeaturePlot_SortingPanel.pdf")
pdf(paste0(dir_save, feature_plots), height = 24, width = 6)
print(feature_plot)
invisible(dev.off())
```

::: panel-tabset
## Relative Expression

```{r, echo = FALSE}
#| fig-height: 13

print(vln_plot_rel)
```

## Counts

```{r, echo = FALSE}
#| fig-height: 13

print(vln_plot_cnt)
```

## Feature Plots

```{r, echo = FALSE}
#| fig-height: 25.5

print(feature_plot)
```
:::

### Assign cell types

Predict cell types based on expression using sc-Type

```{r, warning = FALSE}
# Load gene set preparation function 
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")

# Load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")
```

Prepare gene sets from input cell marker file. This uses the default of in-built cell marker DB.

```{r, warning = FALSE}
# DB file
#db_ <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";

db_ <- "data/ScTypeDB_full_MLedit.xlsx"
tissue <- "Immune system" # e.g. Immune system, Pancreas, Liver, Eye, Kidney, Brain, Lung, Adrenal, Heart, Intestine, Muscle, Placenta, Spleen, Stomach, Thymus 

# prepare gene sets
gs_list <- gene_sets_prepare(db_, tissue)
```

Run sc-Type.

```{r, message = FALSE}

### CHANGE Idents(obj) to obj@meta.data$seurat_clusters

# check Seurat object version (scRNA-seq matrix extracted differently in Seurat v4/v5)
seurat_package_v5 <- isFALSE('counts' %in% names(attributes(obj[["RNA"]])));
print(sprintf("Seurat object %s is used", ifelse(seurat_package_v5, "v5", "v4")))

# extract scaled scRNA-seq matrix
scRNAseqData_scaled <- if (seurat_package_v5) as.matrix(obj[["RNA"]]$scale.data) else as.matrix(obj[["RNA"]]@scale.data)

# run ScType
es.max <- sctype_score(scRNAseqData = scRNAseqData_scaled, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# merge by cluster
cL_resutls <- do.call("rbind", lapply(unique(Idents(obj)), function(cl){
  es.max.cl = sort(rowSums(es.max[ ,rownames(obj@meta.data[Idents(obj)==cl, ])]), decreasing = !0)
  head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(Idents(obj)==cl)), 10)
}))
sctype_scores <- cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] <- "Unknown"
print(sctype_scores)
```

Overlay cell type IDs on UMAP.

```{r}
### CHANGE Idents(obj) to obj@meta.data$seurat_clusters

obj@meta.data$sctype_classification = NA
for(j in unique(sctype_scores$cluster)){
  cl_type = sctype_scores[sctype_scores$cluster==j,]; 
  obj@meta.data$sctype_classification[Idents(obj) == j] = as.character(cl_type$type[1])
}

pdf(paste0(dir_save, "umap_annotated.pdf"), height = 7, width = 10)
umap_annotated <- DimPlot(obj, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'sctype_classification')
print(umap_annotated)
invisible(dev.off())
umap_annotated
```

```{r}
#| fig-height: 6.5

pdf(paste0(dir_save, "umap_annotated_splitgroup.pdf"), height = 7, width = 15)
umap_annotated_group <- DimPlot(obj, reduction = "umap", split.by = "group", group.by = 'sctype_classification')
print(umap_annotated_group)
invisible(dev.off())
umap_annotated_group
```

### Create proportion plots for clusters

```{r, eval = FALSE}

########### DOWNSAMPLE TO SAME NUMBER OF CELLS PER VISIT PER GROUP

metadata <- obj@meta.data

cluster_names <- metadata %>% 
  select(RNA_snn_res.0.6, sctype_classification) %>% 
  mutate(sctype_classification = as.character(sctype_classification))

rownames(cluster_names) <- NULL

cluster_names <- cluster_names %>% 
  unique()

#sctype
# Calculate the total number of cells per sample
total_cells_per_sample <- metadata %>%
  group_by(VISIT, PID, sctype_classification) %>%
  summarize(total_cells = n())

# Calculate the number of cells per cluster per sample
cells_per_cluster_sample <- metadata %>%
  group_by(STIM, VISIT, PID, sctype_classification) %>%
  summarize(cluster_cells = n()) %>%
  ungroup()

# Calculate the proportion of cells in each cluster for each sample
proportions <- cells_per_cluster_sample %>%
  left_join(total_cells_per_sample, by = c("VISIT", "PID", "sctype_classification")) %>%
  mutate(proportion = cluster_cells / total_cells) %>%
  select(STIM, VISIT, PID, sctype_classification, proportion)

# Pivot the data to create a matrix
proportion_df <- proportions %>%
  pivot_wider(names_from = sctype_classification, values_from = proportion)

test <- proportion_df %>% 
  pivot_longer(4:21, names_to = "sctype_classification", values_to = "Prop") %>% 
  mutate(sctype_classification = as.character(sctype_classification)) %>% 
  left_join(cluster_names, by = "sctype_classification") 

# Plot proportions
p_bar_cell <- test %>% 
  ggplot(aes(x = sctype_classification, y = Prop, fill = STIM)) +
  geom_bar(aes(alpha = 0.8),
           stat = "summary",
           fun = "median",
           color = "black") +
  facet_grid(PID ~ VISIT) +  
  ylab("Proportion of cells") +
  xlab(NULL) +
  guides(alpha = "none",
         fill = guide_legend(override.aes = list(alpha = 0.8))) +
  ggpubr::theme_pubr(base_size = 20, legend = "bottom", x.text.angle = 90)

cowplot::ggsave2(file.path(dir_save, 'p_bar_cell_STIM_sctype.png'), p_bar_cell,
                 units = 'cm',
                 width = 15,
                 height = 45)
p_bar_cell




#RNA_snn_res.1.2
# Calculate the total number of cells per sample
total_cells_per_sample <- metadata %>%
  group_by(VISIT, PID, RNA_snn_res.1.2) %>%
  summarize(total_cells = n())

# Calculate the number of cells per cluster per sample
cells_per_cluster_sample <- metadata %>%
  group_by(STIM, VISIT, PID, RNA_snn_res.0.6) %>%
  summarize(cluster_cells = n()) %>%
  ungroup()

# Calculate the proportion of cells in each cluster for each sample
proportions <- cells_per_cluster_sample %>%
  left_join(total_cells_per_sample, by = c("VISIT", "PID", "RNA_snn_res.0.6")) %>%
  mutate(proportion = cluster_cells / total_cells) %>%
  select(STIM, VISIT, PID, RNA_snn_res.0.6, proportion)

# Pivot the data to create a matrix
proportion_df <- proportions %>%
  pivot_wider(names_from = RNA_snn_res.0.6, values_from = proportion)

# Convert to matrix
#proportion_matrix <- as.matrix(proportion_df [,-1])
#rownames(proportion_matrix) <- proportion_df$SampleName

test <- proportion_df %>% 
  #as.data.frame() %>% 
  #tibble::rownames_to_column(var = "group") %>% 
  pivot_longer(4:20, names_to = "RNA_snn_res.0.6", values_to = "Prop") %>% 
  mutate(RNA_snn_res.0.6 = as.character(RNA_snn_res.0.6)) %>% 
  left_join(cluster_names, by = "RNA_snn_res.0.6") #%>% 
  #select(-RNA_snn_res.0.6) #%>% 
  #pivot_wider(names_from = "cell_type", values_from = "Prop")

p_bar_cell <- test %>% 
  ggplot(aes(x = RNA_snn_res.0.6, y = Prop, fill = STIM)) +
  geom_bar(aes(alpha = 0.8),
           stat = "summary",
           fun = "median",
           color = "black") +
  facet_grid(PID ~ VISIT) +  # This creates separate plots for each VISIT value
  ylab("Proportion of cells") +
  xlab(NULL) +
  guides(alpha = "none",
         fill = guide_legend(override.aes = list(alpha = 0.8))) +
  ggpubr::theme_pubr(base_size = 20, legend = "bottom", x.text.angle = 90)

# Save the plot
cowplot::ggsave2(file.path(dir_save, 'p_bar_cell_STIM_RNA_snn_res.0.6.png'), p_bar_cell,
                 units = 'cm',
                 width = 30,
                 height = 20)








#sctype

cluster_names <- metadata %>% 
  select(VISIT_STIM)

rownames(cluster_names) <- NULL

cluster_names <- cluster_names %>% 
  unique()

# Calculate the total number of cells per sample
total_cells_per_sample <- metadata %>%
  group_by(VISIT_STIM) %>%
  summarize(total_cells = n())

# Calculate the number of cells per cluster per sample
cells_per_cluster_sample <- metadata %>%
  group_by(VISIT_STIM, sctype_classification) %>%
  summarize(cluster_cells = n()) %>%
  ungroup()

# Calculate the proportion of cells in each cluster for each sample
proportions <- cells_per_cluster_sample %>%
  left_join(total_cells_per_sample, by = "VISIT_STIM") %>%
  mutate(proportion = cluster_cells / total_cells) %>%
  select(VISIT_STIM, sctype_classification, proportion)

# Pivot the data to create a matrix
proportion_df <- proportions %>%
  pivot_wider(names_from = VISIT_STIM, values_from = proportion)

# Convert to matrix
#proportion_matrix <- as.matrix(proportion_df [,-1])
#rownames(proportion_matrix) <- proportion_df$SampleName

test <- proportion_df %>% 
  #as.data.frame() %>% 
  #tibble::rownames_to_column(var = "group") %>% 
  pivot_longer(2:5, names_to = "VISIT_STIM", values_to = "Prop") %>% 
  mutate(VISIT_STIM = as.character(VISIT_STIM)) %>% 
  left_join(cluster_names, by = "VISIT_STIM") #%>% 
  #select(-RNA_snn_res.0.6) #%>% 
  #pivot_wider(names_from = "cell_type", values_from = "Prop")

p_bar_cell <- test %>% 
  ggplot(aes(x = VISIT_STIM, y = Prop, fill = sctype_classification)) +
  geom_bar(aes(alpha = 0.8),
           stat = "summary",
           fun = "median",
           color = "black") +
  #facet_wrap(~ VISIT) +  # This creates separate plots for each VISIT value
  ylab("Proportion of cells") +
  xlab(NULL) +
  guides(alpha = "none",
         fill = guide_legend(override.aes = list(alpha = 0.8))) +
  ggpubr::theme_pubr(base_size = 20, legend = "bottom", x.text.angle = 90)

# Save the plot
cowplot::ggsave2(file.path(dir_save, 'p_bar_cell_STIM_sctype.png'), p_bar_cell,
                 units = 'cm',
                 width = 30,
                 height = 20)








###########################################
# Extract metadata
metadata <- obj@meta.data

# Get unique clusters and stimulation groups
clusters <- unique(metadata$seurat_clusters)
stim_groups <- unique(metadata$STIM)

# Initialize an empty list to store results
results_list <- list()

# Iterate over each stimulation group and cluster to calculate the metrics
for (stim in stim_groups) {
  for (cluster in clusters) {
    # Subset metadata for the current stim and cluster
    subset_metadata <- metadata %>% 
      filter(seurat_clusters == cluster, STIM == stim)
    
    # Calculate metrics
    mapped_reads <- mean(subset_metadata$reads.mapped, na.rm = TRUE)
    exon_reads <- mean(subset_metadata$ExonReads, na.rm = TRUE)
    intron_reads <- mean(subset_metadata$IntronReads, na.rm = TRUE)
    nTrans <- mean(subset_metadata$nCount_RNA, na.rm = TRUE)
    nGenes <- mean(subset_metadata$nFeature_RNA, na.rm = TRUE)
    percMito <- mean(subset_metadata$percent.mito, na.rm = TRUE)
    nCells <- nrow(subset_metadata)
    
    # Create a data frame with the calculated metrics
    metrics_df <- data.frame(
      Stimulation = stim,
      Cluster = cluster,
      MappedReads = mapped_reads,
      ExonReads = exon_reads,
      IntronReads = intron_reads,
      nTrans = nTrans,
      nGenes = nGenes,
      percMito = percMito,
      nCells = nCells
    )
    
    # Append the data frame to the results list
    results_list[[paste0("Cluster", cluster, "_Stim", stim)]] <- metrics_df
  }
}

# Combine all results into a single data frame
summary_table <- bind_rows(results_list, .id = "Cluster_Stim")

# Reshape the summary table to have clusters and stimulations as columns
summary_table_wide <- summary_table %>% 
  pivot_wider(names_from = Cluster_Stim, values_from = c(MappedReads, ExonReads, IntronReads, nTrans, nGenes, percMito, nCells))

# View the summary table
View(summary_table_wide)

```

### Identify conserved cell type markers

```{r, eval = FALSE}
#Idents(obj) <- "sctype_classification"

# Create a list of all sctype classifications in obj
# sctype.types <- levels(Idents(obj))

# Initialize a list to store cluster markers
#cluster.markers <- list()

# Loop through each Seurat cluster in obj

#for (sctype.type in sctype.types) {
  
  #sctype.markers <- FindConservedMarkers(obj, ident.1 = sctype.type, grouping.var = "group", verbose = FALSE)
  
  #
  
  # Identify differentially expressed genes
  
  
#}


```

### Overlay expression of ADTs on RNA clusters

```{r}
# Create a list of all cluster identities in obj
cluster.ids <- levels(Idents(obj))

# Initialize a list to store cluster markers
cluster.markers.RNAandADT <- list()

# Normalize the ADT data
DefaultAssay(obj) <- "ADT"
obj <- NormalizeData(obj, normalization.method = "CLR", margin = 2)

# Loop through each Seurat cluster in obj
for (cluster.id in cluster.ids) {
  
  # Find genes for RNA assay sorted by adjusted p value 
  genes_RNA <- FindMarkers(obj, ident.1 = cluster.id, assay = "RNA")
  genes_RNA <- rownames(genes_RNA[order(genes_RNA$p_val_adj), ])
  
  # Find genes for ADT assay sorted by adjusted p value 
  genes_ADT <- FindMarkers(obj, ident.1 = cluster.id, assay = "ADT")
  genes_ADT <- rownames(genes_ADT[order(genes_ADT$p_val_adj), ])
  
  # Find common genes between RNA and ADT assays
  cluster.markers.RNAandADT <- intersect(genes_RNA, genes_ADT)
  
  object.name <- paste0("cluster.markers.", cluster.id)

  # Plot violin plots of relative expression 
  DefaultAssay(obj) <- "RNA"
  vln_RNA <- VlnPlot(obj,
                      features = c(cluster.markers.RNAandADT)[1:10],
                      log = TRUE,
                      ncol = 1,
                      pt.size = 0) 
  main_title <- ggdraw() + 
  draw_label(paste0("RNA Cluster ", cluster.id), fontface = "bold", size = 14, hjust = 0.5)
  vln_RNA <- plot_grid(main_title, vln_RNA, nrow = 2, rel_heights = c(0.05, 0.95))


  DefaultAssay(obj) <- "ADT"
  vln_ADT <- VlnPlot(obj,
                      features = c(cluster.markers.RNAandADT)[1:10],
                      log = TRUE,
                      ncol = 1,
                      pt.size = 0)
  main_title <- ggdraw() + 
  draw_label(paste0("ADT Cluster ", cluster.id), fontface = "bold", size = 14, hjust = 0.5)
  vln_ADT <- plot_grid(main_title, vln_ADT, nrow = 2, rel_heights = c(0.05, 0.95))
  
  vln_plots <- paste0("Multimodal_DEG_VlnPlotRelExp_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, vln_plots), height = 30, width = 10)
  print(vln_RNA | vln_ADT)
  dev.off()
  
  # Plot feature plots overlaid onto UMAP
  
  DefaultAssay(obj) <- "RNA"
  feature_RNA <- FeaturePlot(obj,
                              features = c(cluster.markers.RNAandADT)[1:10],
                              label = TRUE,
                              label.size = 4,
                              ncol = 1,
                              pt.size = 0)
  main_title <- ggdraw() + 
  draw_label(paste0("RNA Cluster ", cluster.id), fontface = "bold", size = 14, hjust = 0.5)
  feature_RNA <- plot_grid(main_title, feature_RNA, nrow = 2, rel_heights = c(0.05, 0.95))
  
  DefaultAssay(obj) <- "ADT"
  feature_ADT <- FeaturePlot(obj,
                              features = c(cluster.markers.RNAandADT)[1:10],
                              label = TRUE,
                              label.size = 4,
                              ncol = 1,
                              pt.size = 0)
  main_title <- ggdraw() + 
  draw_label(paste0("ADT Cluster ", cluster.id), fontface = "bold", size = 14, hjust = 0.5)
  feature_ADT <- plot_grid(main_title, feature_ADT, nrow = 2, rel_heights = c(0.05, 0.95))
  
  feature_plots <- paste0("Multimodal_DEG_FeaturePlot_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, feature_plots), height = 30, width = 10)
  print(feature_RNA | feature_ADT)
  dev.off()
}
```

```{r}
save(obj, file = paste0(dir_save, "Seurat_ClusterIDCellsRNAonly_obj.Rdata"))
saveRDS(obj, file = paste0(dir_save, "Seurat_ClusterIDCellsRNAonly_obj.rds"))
```

## ADT (Protein)

### Split the object into multiple layers for integration based on the ADT Assay

Integration is performed to account for batch effects. Therefore, the factor used to split the object into multiple layers should be the factor that provides information on which batch the samples came from. In this case, each batch has a unique RUN ID. The metadata column for that contains the RUN IDs is called "RUN" and should be used to integrate layers.

```{r}
DefaultAssay(obj) <- "ADT"
```

### Split the object into multiple layers for integration based on ADT Assay

```{r, warning = FALSE}
obj[["ADT"]] <- split(obj[["ADT"]], f = obj$RUN)
obj
```

### Normalize the ADT data

For the ADT assay we use Seurat NormalizeData function to perform CLR normalization with a margin of 2.

```{r, message = FALSE}
obj <- NormalizeData(obj, normalization.method = "CLR", margin = 2)
```

### Identify variable features

We allow all 165 ADTs as variable features for downstream analyses using the standard Seurat FindVariableFeatures function with selection method "vst".

```{r, message = FALSE}
obj <- FindVariableFeatures(obj, selection.method = "vst", nfeatures = 165)

# Identify the 10 most highly variable genes
top10.adt <- head(VariableFeatures(obj), 10)

# plot variable features and label top 10 variable features
plot1 <- VariableFeaturePlot(obj)
plot2 <-LabelPoints(plot = plot1, points = top10.adt, repel = TRUE)
```

```{r, echo = FALSE, warning = FALSE}
print(plot2)
```

### Scale the ADT data

Data is scaled using only variable features by default.

```{r}
obj <- ScaleData(obj)
```

### Perform linear dimensional reduction

Principal component analysis (PCA) is used for linear dimensional reduction of scaled data. PCA is run with default options. The plots below visualize dimensional reduction genes for principal components (PC) 1 and 2, display cell positioning in 2D, and a heatmap of genes associated with the top 1 and 15 PCs for all cells.

```{r, output = FALSE}
# Perform PCA for linear dimensional reduction on scaled data. Give reduction a new name to avoid overwriting RNA reduction. 
obj <- RunPCA(obj, features = NULL, reduction.name = 'pca.adt') 

# Examine and visualize PCA results a few different ways

plot1 <- VizDimLoadings(obj, dims = 1:2, reduction = "pca.adt")

plot2 <- DimPlot(obj, reduction = "pca.adt") + NoLegend()

plot3 <- DimHeatmap(obj, reduction = "pca.adt", dims = 1, cells = 500, balanced = TRUE)

plot4 <- DimHeatmap(obj, reduction = "pca.adt", dims = 1:6, cells = 500, balanced = TRUE)
```

```{r, echo = FALSE}
print(plot1)
print(plot2)
DimHeatmap(obj, reduction = "pca.adt", dims = 1, cells = 500, balanced = TRUE)
```

```{r, echo = FALSE}
#| fig-height: 13
DimHeatmap(obj, reduction = "pca.adt", dims = 1:6, cells = 500, balanced = TRUE)
```

### Examine variance explained by each principal component

Here we look at the variance in the dataset that is explained by each individual PC and at the cumulative variance explained by the PCs.

We also determine the dimensionality of the dataset using an Elbow plot (more efficient alternative to JackStraw procedure).

```{r}
pca = obj[["pca.adt"]]

# Get the eigenvalues
evs = pca@stdev^2
total.var = pca@misc$total.variance
varExplained = evs/total.var
pca.data = data.frame(PC=factor(1:length(evs)),
                      percVar=varExplained*100)
pca.data$cumulVar = cumsum(pca.data$percVar)

head(pca.data, 20)

scPlot1 <- pca.data[1:10,] %>%
          ggplot(aes(x=PC, y=percVar)) +
          geom_bar(stat='identity') +
          geom_hline(yintercept = 1, colour="red", linetype=3) +
          labs(title="Variance Explanation by PCA") +
          xlab("Principal Components") +
          ylab("Percentage of Explained Variance") +
          theme_bw()

scPlot2 <- pca.data[1:10,] %>%
          ggplot(aes(x=PC, y=cumulVar)) +
          geom_bar(stat='identity') +
          geom_hline(yintercept = 50, colour="red", linetype=3) +
          labs(title="Cumulative Variance Explanation by PCA") +
          xlab("Principal Components") +
          ylab("Cumulative Percentage of Explained Variance") +
          theme_bw()

elbow <- ElbowPlot(obj)
```

```{r, echo = FALSE}
print(scPlot1)
print(scPlot2)
print(elbow)
```

### Cluster cells based on ADT

Start with standard Seurat clustering method WITHOUT INTEGRATION. Use the bar and Elbow plots to determine minimum dimensions to use for clustering. Clustering is performed using UMAP for non-linear dimensional reduction. The number of dimensions is set to 30. PCA is used to find neighbors and clusters and for UMAP reduction.

The tabulated plots visualize the basic UMAP with seurat clusters for all cells and conditions as well as UMAPs grouped by metadata features and split by group.

```{r, message=FALSE}
obj <- FindNeighbors(obj, reduction = "pca.adt") 
obj <- FindClusters(obj, cluster.name = "unintegrated_clusters_adt") 
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca.adt", reduction.name = "umap.unintegrated.adt")

plot1 <- DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("seurat_clusters"), split.by = "group")
plot2 <- DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("RUN", "seurat_clusters"), split.by = "group")
plot3 <- DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("STIM", "seurat_clusters"), split.by = "group")
plot4 <- DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("PID", "seurat_clusters"), split.by = "group")
plot5 <- DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("VISIT", "seurat_clusters"), split.by = "group")
plot6 <- DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

::: panel-tabset
## UMAP group

```{r, echo = FALSE}
print(plot1)
```

## UMAP RUN

```{r, echo = FALSE}
#| fig-height: 10
print(plot2)
```

## UMAP STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot3)
```

## UMAP PID

```{r, echo = FALSE}
#| fig-height: 10
print(plot4)
```

## UMAP VISIT

```{r, echo = FALSE}
#| fig-height: 10
print(plot5)
```

## UMAP VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot6)
```
:::

### Inspect cluster proportions on unintegrated clusters

Next we examine the proportion of each cluster that is comprised of cells with key metadata features: RUN, group, STIM, PID, and VISIT. Proportions are shown alongside total cell number per cluster.

```{r, warning = FALSE, message = FALSE}
plot_integrated_clusters = function (srat, batchcolumn) {
  ## take an integrated Seurat object, plot distributions over orig.ident

  count_table <- table(srat@meta.data$seurat_clusters, srat@meta.data[[batchcolumn]])
  count_mtx   <- as.data.frame.matrix(count_table)
  count_mtx$cluster <- rownames(count_mtx)
  melt_mtx    <- melt(count_mtx)
  melt_mtx$cluster <- as.factor(melt_mtx$cluster)

  cluster_size   <- aggregate(value ~ cluster, data = melt_mtx, FUN = sum)

  sorted_labels <- paste(sort(as.integer(levels(cluster_size$cluster)),decreasing = T))
  cluster_size$cluster <- factor(cluster_size$cluster,levels = sorted_labels)
  melt_mtx$cluster <- factor(melt_mtx$cluster,levels = sorted_labels)

  colnames(melt_mtx)[2] <- "dataset"


  p1 <- ggplot(cluster_size, aes(y= cluster,x = value)) + geom_bar(position="dodge", stat="identity",fill = "grey60") +
    theme_bw() + scale_x_log10() + xlab("Cells per cluster, log10 scale") + ylab("")
  p2 <- ggplot(melt_mtx,aes(x=cluster,y=value,fill=dataset)) +
    geom_bar(position="fill", stat="identity") + theme_bw() + coord_flip() +
    #scale_fill_brewer(palette = "Set2") +
    ylab("Fraction of cells in each dataset") + xlab("Cluster number") + theme(legend.position="top")

  p2 + p1 + plot_layout(widths = c(3,1))
}


plot1 <- plot_integrated_clusters(obj, 'group')
plot2 <- plot_integrated_clusters(obj, 'RUN')
plot3 <- plot_integrated_clusters(obj, 'STIM')
plot4 <- plot_integrated_clusters(obj, 'PID')
plot5 <- plot_integrated_clusters(obj, 'VISIT')
plot6 <- plot_integrated_clusters(obj, 'VISIT_STIM')
```

::: panel-tabset
## Proportions group

```{r, echo = FALSE}
print(plot1)
```

## Proportions RUN

```{r, echo = FALSE}
print(plot2)
```

## Proportions STIM

```{r, echo = FALSE}
print(plot3)
```

## Proportions PID

```{r, echo = FALSE}
print(plot4)
```

## Proportions VISIT

```{r, echo = FALSE}
print(plot5)
```

## Proportions VISIT & STIM

```{r, echo = FALSE}
print(plot6)
```
:::

### Perform integration of ADT Assay

Integration is performed using the RUN metadata variable. Each RUN is representative of a single experimental processing batch which includes samples from two PIDs at both time points. Each RUN therefore can be seen as an individual batch and can be used in integration to adjust for experimentally-introduced batch effects.

```{r}
obj <- IntegrateLayers(object = obj, 
                       method = CCAIntegration, 
                       orig.reduction = "pca.adt", 
                       new.reduction = "integrated.cca.adt", 
                       verbose = FALSE)

obj[["ADT"]] <- JoinLayers(obj[["ADT"]])

obj <- FindNeighbors(obj, reduction = "integrated.cca.adt", dims = 1:30) 
obj <- FindClusters(obj, resolution = 1.2)

obj <- RunUMAP(obj, dims = 1:30, reduction = "integrated.cca.adt", reduction.name = "umap.adt") 

plot1 <- DimPlot(obj, reduction = "umap.adt", group.by = c("seurat_clusters"), split.by = "group")
plot2 <- DimPlot(obj, reduction = "umap.adt", group.by = c("RUN", "seurat_clusters"), split.by = "group")
plot3 <- DimPlot(obj, reduction = "umap.adt", group.by = c("STIM", "seurat_clusters"), split.by = "group")
plot4 <- DimPlot(obj, reduction = "umap.adt", group.by = c("PID", "seurat_clusters"), split.by = "group")
plot5 <- DimPlot(obj, reduction = "umap.adt", group.by = c("VISIT", "seurat_clusters"), split.by = "group")
plot6 <- DimPlot(obj, reduction = "umap.adt", group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

::: panel-tabset
## UMAP group

```{r, echo = FALSE}
print(plot1)
```

## UMAP RUN

```{r, echo = FALSE}
#| fig-height: 10

print(plot2)
```

## UMAP STIM

```{r, echo = FALSE}
#| fig-height: 10

print(plot3)
```

## UMAP PID

```{r, echo = FALSE}
#| fig-height: 10

print(plot4)
```

## UMAP VISIT

```{r, echo = FALSE}
#| fig-height: 10

print(plot5)
```

## UMAP VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10

print(plot6)
```
:::

### Inspect RUN metrics on integrated clusters

Now that integration is complete, we will re-examine the proportion of each cluster that is comprised of cells with key metadata features: RUN, group, PID, VISIT, and STIM. Proportions are shown alongside total cell number per cluster. Compare these outputs to those above for unintegrated clusters to determine how cluster composition was changed by integration.

```{r}
plot1 <- plot_integrated_clusters(obj, 'group')
plot2 <- plot_integrated_clusters(obj, 'RUN')
plot3 <- plot_integrated_clusters(obj, 'STIM')
plot4 <- plot_integrated_clusters(obj, 'PID')
plot5 <- plot_integrated_clusters(obj, 'VISIT')
plot6 <- plot_integrated_clusters(obj, 'VISIT_STIM')
```

::: panel-tabset
## Proportions group

```{r, echo = FALSE}
print(plot1)
```

## Proportions RUN

```{r, echo = FALSE}
print(plot2)
```

## Proportions STIM

```{r, echo = FALSE}
print(plot3)
```

## Proportions PID

```{r, echo = FALSE}
print(plot4)
```

## Proportions VISIT

```{r, echo = FALSE}
print(plot5)
```

## Proportions VISIT & STIM

```{r, echo = FALSE}
print(plot6)
```
:::

### Determine more accurate cluster resolution using clustree

Iterating through different resolutions using the clustree package can help determine what resolution best fits the data so that it can be used for downstream analyses. Using clustree, we iterate the clustering algorithm over a resolution range of 0.2 - 2, increasing by 0.2 with each round. We then plot the UMAPs for a representative selection of these iterations to determine what resolution to select moving forward.

```{r, message=FALSE, output = FALSE}
#| fig-height: 13

resolution.range <- seq(from =0.2, to = 2, by = 0.2)
obj <- Seurat::FindClusters(object = obj, resolution = resolution.range)

clustree <- clustree(obj, prefix = "ADT_snn_res.")

pdf(paste0(dir_save, "clustree.all_adt.pdf"))
clustree_plot <- clustree
print(clustree_plot)
invisible(dev.off())

umap.0.4.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.0.4")
umap.0.6.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.0.6")
umap.0.8.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.0.8")
umap.1.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.1")
umap.1.2.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.1.2")

snn_all.adt <- (umap.0.4.adt | umap.0.6.adt) / (umap.0.8.adt | umap.1.adt) / umap.1.2.adt

pdf(paste0(dir_save, "umap_snn_compare_adt.pdf"), width = 20, height = 20)
snn_all.adt
invisible(dev.off())
```

```{r, echo = FALSE}
#| fig-height: 13

print(snn_all.adt)
```

### Visualize clusters

Based on the clustree analysis, the optimal resolution for this dataset is 1.2.We set cluster identities to those associated with resolution = 1.2 and use these identities for further analysis.

```{r, message=FALSE}
# Select which resolution to use based on clustree analysis and assign optimal cluster IDs to Idents
Idents(object = obj) <- "ADT_snn_res.0.6"

# Plot UMAP
pdf(paste0(dir_save, "umap_res.clustree_adt.pdf"))
plot1 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 6)
print(plot1)
invisible(dev.off())

# Plot Feature plot to ensure clustering is not driven by QC artifacts
pdf(paste0(dir_save, "umap_res.clustree_adt_QC.pdf"))
QC_feature <- FeaturePlot(obj, features = c("nCount_RNA", "nFeature_RNA", "percent.mito", "Complexity"))
print(QC_feature)
invisible(dev.off())
```

```{r, echo = FALSE}
print(plot1)
print(QC_feature)
```

To explore how clustering differs for various metadata features, we plot the optimized UMAP and group and split by features of interest.

```{r}
pdf(paste0(dir_save, "umap_allRUN_res.clustree_adt.pdf"), height = 6, width = 25)
plot1 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "RUN",
        repel = T,
        ncol = 2)
print(plot1)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allHIVES_res.clustree_adt.pdf"), height = 6, width = 25)
plot2 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "HIVE",
        repel = T,
        ncol = 2)
print(plot2)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allPID_res.clustree_adt.pdf"), height = 6, width = 25)
plot3 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "PID",
        repel = T,
        ncol = 2)
print(plot3)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allSTIM_res.clustree_adt.pdf"), height = 6, width = 20)
plot4 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "STIM",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot4)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allVISIT_res.clustree_adt.pdf"), height = 6, width = 20)
plot5 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "VISIT",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot5)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allConditions_res.clustree_adt.pdf"), height = 6, width = 20)
plot6 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = c("group", "STIM"),
        split.by = "VISIT",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot6)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allConditionsAlternative_res.clustree_adt.pdf"), height = 6, width = 20)
plot7 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = c("VISIT", "STIM"),
        split.by = "group",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot7)
invisible(dev.off())
```

::: panel-tabset
## RUN

```{r, echo = FALSE}
#| fig-height: 19

print(plot1)
```

## HIVEs

```{r, echo = FALSE}
#| fig-height: 19

print(plot2)
```

## PID

```{r, echo = FALSE}
#| fig-height: 32

print(plot3)
```

## STIM

```{r, echo = FALSE}
print(plot4)
```

## VISIT

```{r, echo = FALSE}
print(plot5)
```

## PID & VISIT

```{r, echo = FALSE}
#| fig-height: 9.5

print(plot6)
```

## PID & VISIT Alternative

```{r, echo = FALSE}
#| fig-height: 9.5

print(plot7)
```
:::

### Determine marker expression by cluster

Find markers for every cell cluster compared to all remaining cells, report only the positive ones. Save a .csv file that contains the markers for each cluster.

```{r, message=FALSE}
obj.markers.adt <- FindAllMarkers(obj, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)

obj.markers.adt %>%
  group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1)

write.csv(obj.markers.adt, file = file.path(dir_save, "all_markers_snn0.6_adt.csv"), quote = FALSE)
```

### Examine differential expression in clusters

Identify markers differentially expressed between specific clusters of interest and plot differentially expressed features as relative expression and as counts.

cluster.ids.adt \<- levels(Idents(obj)) for (cluster.id in cluster.ids.adt) {

\# Find markers for the current cluster cluster.markers.adt \<- FindMarkers(obj, ident.1 = cluster.id) cluster.markers.adt vln_plot_relexp.adt \<- paste0("DEG_VlnPlotRelExp_Top10\_", object.name, "\_adt.pdf")

```{r, message=FALSE, warning = FALSE}
# Function to create relative expression violin plots 
create_vln_rel <- function(obj) {

  # Plot expression of top 10 differentially expressed genes for the current cluster
   vln_plot_rel <- VlnPlot(obj,
          features = rownames(cluster.markers.adt)[1:10],
          ncol = 2,
          pt.size = 0)
  vln_plot_relexp <- paste0("DEG_VlnPlotRelExp_Top10_", object.name, "_adt.pdf")
  pdf(paste0(dir_save, vln_plot_relexp), height = 12, width = 6)
  print(vln_plot_rel)
  dev.off()

  return(vln_plot_rel)

}

# Function to create counts violin plots
create_vln_cnt <- function(obj) {

  vln_plot_cnt <- VlnPlot(obj,
          features = rownames(cluster.markers.adt)[1:10],
          slot = "counts", 
          log = TRUE, 
          ncol = 2,
          pt.size = 0)
  vln_plot_counts <- paste0("DEG_VlnPlotCounts_Top10_", object.name, "_adt.pdf")
  pdf(paste0(dir_save, vln_plot_counts), height = 12, width = 6)
  print(vln_plot_cnt)
  dev.off()

  return(vln_plot_cnt)

}

# Function to create feature plots
create_feature <- function(obj) {

    feature_plot <- FeaturePlot(obj,
            features = rownames(cluster.markers.adt)[1:10], 
            label = TRUE,
            label.size = 4,
            split.by = "group",
            ncol = 2,
            pt.size = 0)
  feature_plots <- paste0("DEG_FeaturePlot_Top10_", object.name, "_adt.pdf")
  pdf(paste0(dir_save, feature_plots), height = 24, width = 6)
  print(feature_plot)
  dev.off()

  return(feature_plot)

}

# List to store relative expression violin plots
vln_plot_rel_list <- list()

# List to store counts violin plots
vln_plot_cnt_list <- list()

# List to store feature plots
feature_plot_list <- list()

# Create a list of all cluster identities in obj
cluster.ids.adt <- levels(Idents(obj))

# Initialize a list to store cluster markers
cluster.markers.adt <- list()

# Loop through each Seurat cluster in obj
for (cluster.id in cluster.ids.adt) {
  
  # Find markers for the current cluster
  cluster.markers.adt <- FindMarkers(obj, ident.1 = cluster.id)
  
  # Assign a dynamic object name based on the cluster ID
  object.name <- paste0("cluster.markers.", cluster.id)
  
  # Export cluster markers to a CSV file
  csv_file <- paste0(object.name, "_adt.csv")
  write.csv(cluster.markers.adt, file = file.path(dir_save, paste0(csv_file)), row.names = TRUE)
  
  # Create plots using functions
  vln_plot_rel <- create_vln_rel(obj)
  vln_plot_cnt <- create_vln_cnt(obj)
  feature_plot <- create_feature(obj)


  # Assign the plots to a variable with a dynamic name
  assign(paste0("VlnPlotRel_", cluster.id), vln_plot_rel)
  assign(paste0("VlnPlotCnt_", cluster.id), vln_plot_cnt)
  assign(paste0("FeaturePlot_", cluster.id), feature_plot)

  # Add the plots to the associated list
  vln_plot_rel_list[[cluster.id]] <- vln_plot_rel
  vln_plot_cnt_list[[cluster.id]] <- vln_plot_cnt
  feature_plot_list[[cluster.id]] <- feature_plot
  
}

# Plot a heatmap to look at the top 10 differentially expressed genes across all clusters
pdf(paste0(dir_save, "DEG_Heatmap_AllClusters_Top10_adt.pdf"), height = 30, width = 20)
obj.markers.adt %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC) -> top10
plot1 <- DoHeatmap(obj, features = top10$gene) + NoLegend()
invisible(dev.off())

# Find all markers distinguishing an interesting cluster from main PBMC clusters
InterestClustervOthers.markers.adt <- FindMarkers(obj, ident.1 = 4, ident.2 = c(0:3))
```

Plot top 10 differentially expressed genes per cluster as relative expression.

::: panel-tabset
```{r}
#| fig-height: 25.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(vln_plot_rel_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(vln_plot_rel_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Plot top 10 differentially expressed genes per cluster as counts.

::: panel-tabset
```{r}
#| fig-height: 25.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(vln_plot_cnt_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(vln_plot_cnt_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Plot top 10 differentially expressed genes per cluster as feature plots.

::: panel-tabset
```{r}
#| fig-height: 32.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(feature_plot_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(feature_plot_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Examine top 10 features that distinguish each cluster as a heatmap and print the top 10 markers that distinguish a cluster of interest from all others. In this case, we look at the markers that distinguish cluster 4 from all others.

```{r, echo = FALSE, warning = FALSE}
DoHeatmap(obj, features = top10$gene) + NoLegend()
head(InterestClustervOthers.markers.adt, n = 10)
```

### Assign cell types

Predict cell types based on expression using sc-Type

```{r, warning = FALSE}
# Load gene set preparation function 
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")

# Load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")
```

Prepare gene sets from input cell marker file. This uses the default of in-built cell marker DB.

```{r, warning = FALSE}
# DB file
#db_ <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";

db_ <- "data/ScTypeDB_full_CYedit6.xlsx"
tissue <- "Immune system" # e.g. Immune system, Pancreas, Liver, Eye, Kidney, Brain, Lung, Adrenal, Heart, Intestine, Muscle, Placenta, Spleen, Stomach, Thymus 

# prepare gene sets
gs_list <- gene_sets_prepare(db_, tissue)
```

Run sc-Type.

```{r, message = FALSE}

### CHANGE obj@meta.data$seurat_clusters TO Idents(obj)

# check Seurat object version (scRNA-seq matrix extracted differently in Seurat v4/v5)
seurat_package_v5 <- isFALSE('counts' %in% names(attributes(obj[["ADT"]])));
print(sprintf("Seurat object %s is used", ifelse(seurat_package_v5, "v5", "v4")))

# extract scaled scRNA-seq matrix
scRNAseqData_scaled.adt <- if (seurat_package_v5) as.matrix(obj[["ADT"]]$scale.data) else as.matrix(obj[["ADT"]]@scale.data)

# run ScType
es.max.adt <- sctype_score(scRNAseqData = scRNAseqData_scaled.adt, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# merge by cluster
cL_resutls.adt <- do.call("rbind", lapply(unique(obj@meta.data$seurat_clusters), function(cl){
  es.max.cl.adt = sort(rowSums(es.max.adt[ ,rownames(obj@meta.data[obj@meta.data$seurat_clusters==cl, ])]), decreasing = !0)
  head(data.frame(cluster = cl, type = names(es.max.cl.adt), scores = es.max.cl.adt, ncells = sum(obj@meta.data$seurat_clusters==cl)), 10)
}))
sctype_scores.adt <- cL_resutls.adt %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores.adt$type[as.numeric(as.character(sctype_scores.adt$scores)) < sctype_scores.adt$ncells/4] <- "Unknown"
print(sctype_scores.adt[,1:3])
```

Overlay cell type IDs on UMAP.

```{r}
obj@meta.data$sctype_classification.adt = NA
for(j in unique(sctype_scores.adt$cluster)){
  cl_type = sctype_scores.adt[sctype_scores.adt$cluster==j,]; 
  obj@meta.data$sctype_classification.adt[obj@meta.data$seurat_clusters == j] = as.character(cl_type$type[1])
}

pdf(paste0(dir_save, "umap_annotated_adt.pdf"), height = 7, width = 10)
umap_annotated_adt <- DimPlot(obj, reduction = "umap.adt", label = TRUE, repel = TRUE, group.by = 'sctype_classification.adt')
print(umap_annotated_adt)
invisible(dev.off())
umap_annotated_adt
```

```{r}
#| fig-height: 6.5

pdf(paste0(dir_save, "umap_annotated_splitgroup_adt.pdf"), height = 7, width = 15)
umap_annotated_adt_group <- DimPlot(obj, reduction = "umap.adt", split.by = "group", group.by = 'sctype_classification.adt')
print(umap_annotated_adt_group)
invisible(dev.off())
umap_annotated_adt_group
```

## Multimodal

### Identify multimodal neighbors

```{r}
obj <- FindMultiModalNeighbors(
  obj, reduction.list = list("pca", "pca.adt"), 
  dims.list = list(1:30, 1:18), modality.weight.name = "RNA.weight"
)
```

### Cluster and plot based on RNA and ADT assays

```{r}
obj <- RunUMAP(obj, nn.name = "weighted.nn", reduction.name = "wnn.umap", reduction.key = "wnnUMAP_")
obj <- FindClusters(obj, graph.name = "wsnn", algorithm = 3, resolution = 2, verbose = FALSE)

DimPlot(obj, reduction = 'wnn.umap', group.by = c("group", "seurat_clusters"))
```

```{r}
#| fig-height: 6.5

DimPlot(obj, reduction = 'wnn.umap', group.by = c("STIM", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = 'wnn.umap', group.by = c("PID", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = 'wnn.umap', group.by = c("VISIT", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = 'wnn.umap', group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

### Overlay ADT expression over RNA-clustered UMAP.

```{r}

```

### Save Rdata and rds

```{r}
save(obj, file = paste0(dir_save, "Seurat_ClusterIDCells_obj.Rdata"))
saveRDS(obj, file = paste0(dir_save, "Seurat_ClusterIDcells_obj.rds"))
```
