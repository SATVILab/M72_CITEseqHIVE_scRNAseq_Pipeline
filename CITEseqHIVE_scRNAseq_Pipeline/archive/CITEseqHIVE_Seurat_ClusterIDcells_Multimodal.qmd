---
title: "CITEseq-HIVE Seurat Cluster and ID cell types with Multimodal Data"
format: html
editor: visual
---

## Description

This script takes the output of CITEseqHIVE_Seurat_FilterMergeQC.qmd as input. Each Assay ("RNA", and "ADT") will be processed individually first, and then integrated using Weighted Nearest Neighbors (WNN) for combined analysis. Analysis in this script includes normalization and scaling, clustering, and cell type identification.

### Clear console

```{r, output = FALSE}
ls()
rm(list=ls())
```

### Set output directory

```{r}
dir_save <- "output/"
```

### Load libraries

```{r, message = FALSE, warning = FALSE}
library(SingleCellExperiment)
library(Seurat)
library(SeuratObject)
library(tidyr)
library(dplyr)
library(clustree)
library(ggpubr)
library(patchwork)
library(reshape2)
library(RColorBrewer)
library(magrittr)
library(HGNChelper)
library(openxlsx)
library(multtest)
library(metap)
library(ggplot2)
library(cowplot)
library(readxl)
library(devtools)
library(presto)
library(kableExtra)
library(glue)
```

## RNA

Begin by processing the "RNA" assay. In the below section, only RNA expression data will be considered when performing normalization, scaling, clustering, and cell identification steps. ADT data is ignored.

### Load the filtered, merged, .Rdata object and examine structure

The Seurat_FilterMerge_obj.Rdata file generated by CITEseqHIVE_Seurat_FilterMergeQC.qmd serves as input for this pipeline. It should contain only one object, called "obj" which is the filtered and merged Seruat object for all SMARTseq2 plates. 

<details>

<summary>Code</summary>

```{r}
load("output/Seurat_FilterMerge_obj.Rdata")
obj

# Confirm Seruat object contains assays for RNA and ADT
Assays(obj)
```

</details>

```{r, echo = FALSE}
Assays(obj)
```

### Split the object into multiple layers for integration based on the RNA Assay

Integration is performed to account for batch effects. Therefore, the factor used to split the object into multiple layers should be the factor that provides information on which batch the samples came from. In this case, each batch has a unique RUN ID. The metadata column for that contains the RUN IDs is called "RUN" and should be used to integrate layers.

Because this Seurat object contains RNA, HTO, and ADT assays, we will perform integration separately beginning with the RNA assay. 

<details>

<summary>Code</summary>

```{r, warning = FALSE}
############## CONSIDER ADDING INTEGRATION FEATURES #######################

obj[["RNA"]] <- split(obj[["RNA"]], f = obj$RUN)
obj
```

</details>

### Show QC metrics for the first 5 cells and create a metadata object

This is intended to give a snapshot look at some QC metrics and metadata features that can be used for downstream analysis.

<details>

<summary>Code</summary>

```{r}
head(obj@meta.data, 5) %>% 
  kbl() %>% 
  kable_styling()

metadata <- obj@meta.data
```

</details>

### Normalize the RNA data ##################################################################

As this dataset contains only an RNA assay we use standard Seurat NormalizeData function to perform log normalization with a scale factor of 10000.

<details>

<summary>Code</summary>

```{r, message = FALSE}
# Consider changing to SCTransform 
obj <- NormalizeData(obj, normalization.method = "LogNormalize", scale.factor = 10000) 
```

</details>

### Identify variable features

We select the top 2000 variable features for downstream analyses using the standard Seurat FindVariableFeatures function with selection method "vst".

<details>

<summary>Code</summary>

```{r, message = FALSE, warning = FALSE}
# Calculate the top 2000 highly variable features
obj <- FindVariableFeatures(obj, selection.method = "vst", nfeatures = 2000) 

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(obj), 10)

# plot variable features and label top 10 variable features
plot1 <- VariableFeaturePlot(obj)
plot2 <-LabelPoints(plot = plot1, points = top10, repel = TRUE)
```

</details>

```{r, echo = FALSE}
print(plot2)
```

### Scale the RNA data

Data is scaled using only variable features by default.

<details>

<summary>Code</summary>

```{r, message = FALSE}
# Use defaults to scale only variable features 
obj <- ScaleData(obj) 
```

</details>

### Perform linear dimensional reduction

Principal component analysis (PCA) is used for linear dimensional reduction of scaled data. PCA is run with default options. The plots below visualize dimensional reduction genes for principal components (PC) 1 and 2, display cell positioning in 2D, and a heatmap of genes associated with the top 1 and 15 PCs for all cells.

<details>

<summary>Code</summary>

```{r}
# Perform PCA for linear dimensional reduction on scaled data
obj <- RunPCA(obj, features = NULL) 

# Examine and visualize PCA results a few different ways

plot1 <- VizDimLoadings(obj, dims = 1:2, reduction = "pca")

plot2 <- DimPlot(obj, reduction = "pca") + NoLegend()

plot3 <- DimHeatmap(obj, dims = 1, cells = 500, balanced = TRUE)

plot4 <- DimHeatmap(obj, dims = 1:15, cells = 500, balanced = TRUE)
```

</details>

```{r, echo = FALSE}
print(plot1)
print(plot2)
DimHeatmap(obj, dims = 1, cells = 500, balanced = TRUE)
```

```{r, echo = FALSE}
#| fig-height: 19.5
DimHeatmap(object = obj, dims = 1:15, cells = 500, balanced = TRUE) 
```

### Examine variance explained by each principal component

Here we look at the variance in the dataset that is explained by each individual PC and at the cumulative variance explained by the PCs.

We also determine the dimensionality of the dataset using an Elbow plot (more efficient alternative to JackStraw procedure).

<details>

<summary>Code</summary>

```{r}
pca = obj[["pca"]]

# Get the eigenvalues
evs = pca@stdev^2
total.var = pca@misc$total.variance
varExplained = evs/total.var
pca.data = data.frame(PC=factor(1:length(evs)),
                      percVar=varExplained*100)
pca.data$cumulVar = cumsum(pca.data$percVar)

head(pca.data, 20)

scPlot1 <- pca.data[1:10,] %>%
          ggplot(aes(x=PC, y=percVar)) +
          geom_bar(stat='identity') +
          geom_hline(yintercept = 1, colour="red", linetype=3) +
          labs(title="Variance Explanation by PCA") +
          xlab("Principal Components") +
          ylab("Percentage of Explained Variance") +
          theme_bw()

scPlot2 <- pca.data[1:10,] %>%
          ggplot(aes(x=PC, y=cumulVar)) +
          geom_bar(stat='identity') +
          geom_hline(yintercept = 50, colour="red", linetype=3) +
          labs(title="Cumulative Variance Explanation by PCA") +
          xlab("Principal Components") +
          ylab("Cumulative Percentage of Explained Variance") +
          theme_bw()

elbow <- ElbowPlot(obj)
```

</details>

```{r, echo = FALSE}
print(scPlot1)
print(scPlot2)
print(elbow)
```

### Cluster cells based on RNA

Start with standard Seurat clustering method WITHOUT INTEGRATION. Use the bar and Elbow plots to determine minimum dimensions to use for clustering. Clustering is performed using UMAP for non-linear dimensional reduction. The number of dimensions is set to 30. PCA is used to find neighbors and clusters and for UMAP reduction.

The tabulated plots visualize the basic UMAP with seurat clusters for all cells and conditions as well as UMAPs grouped by metadata features and split by group.

<details>

<summary>Code</summary>

```{r, message=FALSE}
obj <- FindNeighbors(obj, reduction = "pca")
obj <- FindClusters(obj, cluster.name = "unintegrated_clusters")
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca", reduction.name = "umap.unintegrated")

plot1 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("seurat_clusters"), split.by = "group")
plot2 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("RUN", "seurat_clusters"), split.by = "group")
plot3 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("STIM", "seurat_clusters"), split.by = "group")
plot4 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("PID", "seurat_clusters"), split.by = "group")
plot5 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("VISIT", "seurat_clusters"), split.by = "group")
plot6 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

</details>

::: panel-tabset
## UMAP group
```{r, echo = FALSE}
print(plot1)
```

## UMAP RUN

```{r, echo = FALSE}
#| fig-height: 10
print(plot2)
```

## UMAP STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot3)
```

## UMAP PID

```{r, echo = FALSE}
#| fig-height: 10
print(plot4)
```

## UMAP VISIT

```{r, echo = FALSE}
#| fig-height: 10
print(plot5)
```

## UMAP VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot6)
```
:::

### Inspect cluster proportions on unintegrated clusters

Next we examine the proportion of each cluster that is comprised of cells with key metadata features: RUN, group, STIM, PID, and VISIT. Proportions are shown alongside total cell number per cluster.

<details>

<summary>Code</summary>

```{r, warning = FALSE, message = FALSE}
plot_integrated_clusters = function (srat, batchcolumn) {
  ## take an integrated Seurat object, plot distributions over orig.ident

  count_table <- table(srat@meta.data$seurat_clusters, srat@meta.data[[batchcolumn]])
  count_mtx   <- as.data.frame.matrix(count_table)
  count_mtx$cluster <- rownames(count_mtx)
  melt_mtx    <- melt(count_mtx)
  melt_mtx$cluster <- as.factor(melt_mtx$cluster)

  cluster_size   <- aggregate(value ~ cluster, data = melt_mtx, FUN = sum)

  sorted_labels <- paste(sort(as.integer(levels(cluster_size$cluster)),decreasing = T))
  cluster_size$cluster <- factor(cluster_size$cluster,levels = sorted_labels)
  melt_mtx$cluster <- factor(melt_mtx$cluster,levels = sorted_labels)

  colnames(melt_mtx)[2] <- "dataset"


  p1 <- ggplot(cluster_size, aes(y= cluster,x = value)) + geom_bar(position="dodge", stat="identity",fill = "grey60") +
    theme_bw() + scale_x_log10() + xlab("Cells per cluster, log10 scale") + ylab("")
  p2 <- ggplot(melt_mtx,aes(x=cluster,y=value,fill=dataset)) +
    geom_bar(position="fill", stat="identity") + theme_bw() + coord_flip() +
    #scale_fill_brewer(palette = "Set2") +
    ylab("Fraction of cells in each dataset") + xlab("Cluster number") + theme(legend.position="top")

  p2 + p1 + plot_layout(widths = c(3,1))
}


plot1 <- plot_integrated_clusters(obj, 'group')
plot2 <- plot_integrated_clusters(obj, 'RUN')
plot3 <- plot_integrated_clusters(obj, 'STIM')
plot4 <- plot_integrated_clusters(obj, 'PID')
plot5 <- plot_integrated_clusters(obj, 'VISIT')
plot6 <- plot_integrated_clusters(obj, 'VISIT_STIM')
```

</details>

::: panel-tabset
## Proportions group

```{r, echo = FALSE}
print(plot1)
```

## Proportions RUN

```{r, echo = FALSE}
print(plot2)
```

## Proportions STIM

```{r, echo = FALSE}
print(plot3)
```

## Proportions PID

```{r, echo = FALSE}
print(plot4)
```

## Proportions VISIT

```{r, echo = FALSE}
print(plot5)
```

## Proportions VISIT & STIM

```{r, echo = FALSE}
print(plot6)
```
:::






### Perform integration of RNA Assay

```{r, message = FALSE}
obj <- IntegrateLayers(object = obj, 
                       method = CCAIntegration, 
                       orig.reduction = "pca", 
                       new.reduction = "integrated.cca", 
                       verbose = FALSE)

obj[["RNA"]] <- JoinLayers(obj[["RNA"]])

obj <- FindNeighbors(obj, reduction = "integrated.cca", dims = 1:30) 
obj <- FindClusters(obj, resolution = 1.2)

obj <- RunUMAP(obj, dims = 1:30, reduction = "integrated.cca") # Change back to 1:12

DimPlot(obj, reduction = "umap", group.by = c("group", "seurat_clusters"))
```

```{r}
#| fig-height: 6.5

DimPlot(obj, reduction = "umap", group.by = c("STIM", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = "umap", group.by = c("PID", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = "umap", group.by = c("VISIT", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = "umap", group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

### Inspect RUN metrics on integrated clusters

```{r}
plot_integrated_clusters(obj, 'RUN')
plot_integrated_clusters(obj, 'group')
plot_integrated_clusters(obj, 'STIM')
plot_integrated_clusters(obj, 'PID')
plot_integrated_clusters(obj, 'VISIT')
plot_integrated_clusters(obj, 'VISIT_STIM')
```
### Determine more accurate cluster resolution using clustree

```{r, message = FALSE, output = FALSE}
#| fig-height: 13

resolution.range <- seq(from =0.2, to = 2, by = 0.2)
obj <- Seurat::FindClusters(object = obj, resolution = resolution.range)

clustree <- clustree(obj, prefix = "RNA_snn_res.")

pdf(paste0(dir_save, "clustree.all.pdf"))
clustree_plot <- clustree
print(clustree_plot)
invisible(dev.off())
clustree_plot

umap.0.4 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.0.4")
umap.0.6 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.0.6")
umap.0.8 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.0.8")
umap.1 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.1")
umap.1.2 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.1.2")

snn_all <- (umap.0.4 | umap.0.6) / (umap.0.8 | umap.1) / umap.1.2

pdf(paste0(dir_save, "umap_snn_compare.pdf"), width = 20, height = 20)
snn_all
invisible(dev.off())

snn_all

Idents(object = obj) <- "RNA_snn_res.1.2"
```

### Visualize clusters

```{r, message=FALSE, warning = FALSE}
# Plot UMAP
pdf(paste0(dir_save, "umap_res.clustree.pdf"))
plot1 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
print(plot1)
invisible(dev.off())
plot1

# Plot Feature plot to ensure clustering is not driven by QC artifacts
pdf(paste0(dir_save, "umap_res.clustree_QC.pdf"))
QC_feature <- FeaturePlot(obj, features = c("nCount_RNA", "nFeature_RNA", "percent.mito", "Complexity"))
print(QC_feature)
invisible(dev.off())
QC_feature
```

```{r}
#| fig-height: 6.5

pdf(paste0(dir_save, "umap_allHIVES_res.clustree.pdf"), height = 6, width = 25)
plot2 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "HIVE",
        repel = T)
print(plot2)
invisible(dev.off())
plot2

pdf(paste0(dir_save, "umap_allPID_res.clustree.pdf"), height = 6, width = 25)
plot3 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "PID",
        repel = T)
print(plot3)
invisible(dev.off())
plot3

pdf(paste0(dir_save, "umap_allSTIM_res.clustree.pdf"), height = 6, width = 20)
plot4 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "STIM",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot4)
invisible(dev.off())
plot4

pdf(paste0(dir_save, "umap_allVISIT_res.clustree.pdf"), height = 6, width = 20)
plot5 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "VISIT",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot5)
invisible(dev.off())
plot5

pdf(paste0(dir_save, "umap_allConditions_res.clustree.pdf"), height = 12, width = 20)
plot6 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = c("group", "STIM"),
        split.by = "VISIT",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot6)
invisible(dev.off())
plot6

pdf(paste0(dir_save, "umap_allConditionsAlternative_res.clustree.pdf"), height = 12, width = 10)
plot7 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = c("VISIT", "STIM"),
        split.by = "group",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot7)
invisible(dev.off())
plot7
```

### Determine marker expression by cluster

Find markers for every cell cluster compared to all remaining cells, report only the positive ones.

```{r, message = FALSE, output = FALSE}
obj.markers <- FindAllMarkers(obj, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)

obj.markers %>%
  group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1)

write.csv(obj.markers, file = file.path(dir_save, "all_markers_snn.clustree.csv"), quote = FALSE)
```

### Identify markers differentially expressed between specific clusters of interest and plot differentially expressed features as relative expression and as counts.

```{r, message = FALSE, warning = FALSE}

# Create a list of all cluster identities in obj
cluster.ids <- levels(Idents(obj))

# Initialize a list to store cluster markers
cluster.markers <- list()

# Loop through each Seurat cluster in obj

for (cluster.id in cluster.ids) {
  
  # Find markers for the current cluster
  cluster.markers <- FindMarkers(obj, ident.1 = cluster.id)
  
  # Assign a dynamic object name based on the cluster ID
  object.name <- paste0("cluster.markers.", cluster.id)
  
  # Export cluster markers to a CSV file
  csv_file <- paste0(object.name, ".csv")
  write.csv(cluster.markers, file = file.path(dir_save, paste0(csv_file)), row.names = TRUE)
  
  # Plot expression of top 10 differentially expressed genes for the current cluster
   vln_plot <- VlnPlot(obj,
          features = rownames(cluster.markers)[1:10],
          ncol = 2,
          pt.size = 0)
  vln_plot_relexp <- paste0("DEG_VlnPlotRelExp_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, vln_plot_relexp), height = 12, width = 6)
  print(vln_plot)
  dev.off()
  
  vln_plot <- VlnPlot(obj,
          features = rownames(cluster.markers)[1:10],
          slot = "counts", 
          log = TRUE, 
          ncol = 2,
          pt.size = 0)
  vln_plot_counts <- paste0("DEG_VlnPlotCounts_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, vln_plot_counts), height = 12, width = 6)
  print(vln_plot)
  dev.off()
  
  feature_plot <- FeaturePlot(obj,
            features = rownames(cluster.markers)[1:10], 
            label = TRUE,
            label.size = 4,
            split.by = "group",
            pt.size = 0)
  feature_plots <- paste0("DEG_FeaturePlot_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, feature_plots), height = 24, width = 6)
  print(feature_plot)
  dev.off()
  
}

# Plot a heatmap to look at the top 10 differentially expressed genes across all clusters
pdf(paste0(dir_save, "DEG_Heatmap_AllClusters_Top10.pdf"), height = 30, width = 20)
obj.markers %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC) -> top10
DoHeatmap(obj, features = top10$gene) + NoLegend()
invisible(dev.off())

# Find all markers distinguishing an interesting cluster from main PBMC clusters
InterestClustervOthers.markers <- FindMarkers(obj, ident.1 = 16, ident.2 = c(0:15, 17:21)) #Automate this line
head(InterestClustervOthers.markers, n = 10)
```
### Visualize expression of sorting panel markers on clusters.

```{r, message=FALSE}
# Plot expression of the sorting panel markers 
 vln_plot <- VlnPlot(obj,
        features = c("CD3G", "CD4", "CD8A", "CD69", "CD40LG", "TNFRSF9"),
        ncol = 2,
        #pt.size = 0.1,
        add.noise = FALSE)
vln_plot_relexp <- paste0("DEG_VlnPlotRelExp_SortingPanel.pdf")
pdf(paste0(dir_save, vln_plot_relexp), height = 12, width = 6)
print(vln_plot)
invisible(dev.off())
vln_plot

vln_plot <- VlnPlot(obj,
        features = c("CD3G", "CD4", "CD8A", "CD69", "CD40LG", "TNFRSF9"),
        slot = "counts", 
        log = TRUE, 
        ncol = 2,
        #pt.size = 0.1,
        add.noise = FALSE)
vln_plot_counts <- paste0("DEG_VlnPlotCounts_SortingPanel.pdf")
pdf(paste0(dir_save, vln_plot_counts), height = 12, width = 6)
print(vln_plot)
invisible(dev.off())
vln_plot

feature_plot <- FeaturePlot(obj,
          features = c("CD3G", "CD4", "CD8A", "CD69", "CD40LG", "TNFRSF9"), 
          label = TRUE,
          label.size = 4,
          split.by = "group",
          pt.size = 0)
feature_plots <- paste0("DEG_FeaturePlot_SortingPanel.pdf")
pdf(paste0(dir_save, feature_plots), height = 24, width = 6)
print(feature_plot)
invisible(dev.off())
feature_plot
```

### Assign cell types

Predict cell types based on expression using sc-Type

```{r}
# Load gene set preparation function 
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")

# Load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")
```

Prepare gene sets from input cell marker file. This uses the default of in-built cell marker DB.

```{r, warning = FALSE}
# DB file
#db_ <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";

db_ <- "data/ScTypeDB_full_MLedit.xlsx"
tissue <- "Immune system" # e.g. Immune system, Pancreas, Liver, Eye, Kidney, Brain, Lung, Adrenal, Heart, Intestine, Muscle, Placenta, Spleen, Stomach, Thymus 

# prepare gene sets
gs_list <- gene_sets_prepare(db_, tissue)
```

Run sc-Type.

```{r, message = FALSE}

### CHANGE Idents(obj) to obj@meta.data$seurat_clusters

# check Seurat object version (scRNA-seq matrix extracted differently in Seurat v4/v5)
seurat_package_v5 <- isFALSE('counts' %in% names(attributes(obj[["RNA"]])));
print(sprintf("Seurat object %s is used", ifelse(seurat_package_v5, "v5", "v4")))

# extract scaled scRNA-seq matrix
scRNAseqData_scaled <- if (seurat_package_v5) as.matrix(obj[["RNA"]]$scale.data) else as.matrix(obj[["RNA"]]@scale.data)

# run ScType
es.max <- sctype_score(scRNAseqData = scRNAseqData_scaled, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# merge by cluster
cL_resutls <- do.call("rbind", lapply(unique(Idents(obj)), function(cl){
  es.max.cl = sort(rowSums(es.max[ ,rownames(obj@meta.data[Idents(obj)==cl, ])]), decreasing = !0)
  head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(Idents(obj)==cl)), 10)
}))
sctype_scores <- cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] <- "Unknown"
print(sctype_scores)
```

Overlay cell type IDs on UMAP.

```{r}
### CHANGE Idents(obj) to obj@meta.data$seurat_clusters

obj@meta.data$sctype_classification = NA
for(j in unique(sctype_scores$cluster)){
  cl_type = sctype_scores[sctype_scores$cluster==j,]; 
  obj@meta.data$sctype_classification[Idents(obj) == j] = as.character(cl_type$type[1])
}

pdf(paste0(dir_save, "umap_annotated.pdf"), height = 7, width = 10)
umap_annotated <- DimPlot(obj, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'sctype_classification')
print(umap_annotated)
invisible(dev.off())
umap_annotated
```

```{r}
#| fig-height: 6.5

pdf(paste0(dir_save, "umap_annotated_splitgroup.pdf"), height = 7, width = 15)
umap_annotated_group <- DimPlot(obj, reduction = "umap", split.by = "group", group.by = 'sctype_classification')
print(umap_annotated_group)
invisible(dev.off())
umap_annotated_group
```
### Create proportion plots for clusters

```{r, eval = FALSE}

########### DOWNSAMPLE TO SAME NUMBER OF CELLS PER VISIT PER GROUP

metadata <- obj@meta.data

cluster_names <- metadata %>% 
  select(RNA_snn_res.0.6, sctype_classification) %>% 
  mutate(sctype_classification = as.character(sctype_classification))

rownames(cluster_names) <- NULL

cluster_names <- cluster_names %>% 
  unique()

#sctype
# Calculate the total number of cells per sample
total_cells_per_sample <- metadata %>%
  group_by(VISIT, PID, sctype_classification) %>%
  summarize(total_cells = n())

# Calculate the number of cells per cluster per sample
cells_per_cluster_sample <- metadata %>%
  group_by(STIM, VISIT, PID, sctype_classification) %>%
  summarize(cluster_cells = n()) %>%
  ungroup()

# Calculate the proportion of cells in each cluster for each sample
proportions <- cells_per_cluster_sample %>%
  left_join(total_cells_per_sample, by = c("VISIT", "PID", "sctype_classification")) %>%
  mutate(proportion = cluster_cells / total_cells) %>%
  select(STIM, VISIT, PID, sctype_classification, proportion)

# Pivot the data to create a matrix
proportion_df <- proportions %>%
  pivot_wider(names_from = sctype_classification, values_from = proportion)

test <- proportion_df %>% 
  pivot_longer(4:21, names_to = "sctype_classification", values_to = "Prop") %>% 
  mutate(sctype_classification = as.character(sctype_classification)) %>% 
  left_join(cluster_names, by = "sctype_classification") 

# Plot proportions
p_bar_cell <- test %>% 
  ggplot(aes(x = sctype_classification, y = Prop, fill = STIM)) +
  geom_bar(aes(alpha = 0.8),
           stat = "summary",
           fun = "median",
           color = "black") +
  facet_grid(PID ~ VISIT) +  
  ylab("Proportion of cells") +
  xlab(NULL) +
  guides(alpha = "none",
         fill = guide_legend(override.aes = list(alpha = 0.8))) +
  ggpubr::theme_pubr(base_size = 20, legend = "bottom", x.text.angle = 90)

cowplot::ggsave2(file.path(dir_save, 'p_bar_cell_STIM_sctype.png'), p_bar_cell,
                 units = 'cm',
                 width = 15,
                 height = 45)
p_bar_cell




#RNA_snn_res.1.2
# Calculate the total number of cells per sample
total_cells_per_sample <- metadata %>%
  group_by(VISIT, PID, RNA_snn_res.1.2) %>%
  summarize(total_cells = n())

# Calculate the number of cells per cluster per sample
cells_per_cluster_sample <- metadata %>%
  group_by(STIM, VISIT, PID, RNA_snn_res.0.6) %>%
  summarize(cluster_cells = n()) %>%
  ungroup()

# Calculate the proportion of cells in each cluster for each sample
proportions <- cells_per_cluster_sample %>%
  left_join(total_cells_per_sample, by = c("VISIT", "PID", "RNA_snn_res.0.6")) %>%
  mutate(proportion = cluster_cells / total_cells) %>%
  select(STIM, VISIT, PID, RNA_snn_res.0.6, proportion)

# Pivot the data to create a matrix
proportion_df <- proportions %>%
  pivot_wider(names_from = RNA_snn_res.0.6, values_from = proportion)

# Convert to matrix
#proportion_matrix <- as.matrix(proportion_df [,-1])
#rownames(proportion_matrix) <- proportion_df$SampleName

test <- proportion_df %>% 
  #as.data.frame() %>% 
  #tibble::rownames_to_column(var = "group") %>% 
  pivot_longer(4:20, names_to = "RNA_snn_res.0.6", values_to = "Prop") %>% 
  mutate(RNA_snn_res.0.6 = as.character(RNA_snn_res.0.6)) %>% 
  left_join(cluster_names, by = "RNA_snn_res.0.6") #%>% 
  #select(-RNA_snn_res.0.6) #%>% 
  #pivot_wider(names_from = "cell_type", values_from = "Prop")

p_bar_cell <- test %>% 
  ggplot(aes(x = RNA_snn_res.0.6, y = Prop, fill = STIM)) +
  geom_bar(aes(alpha = 0.8),
           stat = "summary",
           fun = "median",
           color = "black") +
  facet_grid(PID ~ VISIT) +  # This creates separate plots for each VISIT value
  ylab("Proportion of cells") +
  xlab(NULL) +
  guides(alpha = "none",
         fill = guide_legend(override.aes = list(alpha = 0.8))) +
  ggpubr::theme_pubr(base_size = 20, legend = "bottom", x.text.angle = 90)

# Save the plot
cowplot::ggsave2(file.path(dir_save, 'p_bar_cell_STIM_RNA_snn_res.0.6.png'), p_bar_cell,
                 units = 'cm',
                 width = 30,
                 height = 20)








#sctype

cluster_names <- metadata %>% 
  select(VISIT_STIM)

rownames(cluster_names) <- NULL

cluster_names <- cluster_names %>% 
  unique()

# Calculate the total number of cells per sample
total_cells_per_sample <- metadata %>%
  group_by(VISIT_STIM) %>%
  summarize(total_cells = n())

# Calculate the number of cells per cluster per sample
cells_per_cluster_sample <- metadata %>%
  group_by(VISIT_STIM, sctype_classification) %>%
  summarize(cluster_cells = n()) %>%
  ungroup()

# Calculate the proportion of cells in each cluster for each sample
proportions <- cells_per_cluster_sample %>%
  left_join(total_cells_per_sample, by = "VISIT_STIM") %>%
  mutate(proportion = cluster_cells / total_cells) %>%
  select(VISIT_STIM, sctype_classification, proportion)

# Pivot the data to create a matrix
proportion_df <- proportions %>%
  pivot_wider(names_from = VISIT_STIM, values_from = proportion)

# Convert to matrix
#proportion_matrix <- as.matrix(proportion_df [,-1])
#rownames(proportion_matrix) <- proportion_df$SampleName

test <- proportion_df %>% 
  #as.data.frame() %>% 
  #tibble::rownames_to_column(var = "group") %>% 
  pivot_longer(2:5, names_to = "VISIT_STIM", values_to = "Prop") %>% 
  mutate(VISIT_STIM = as.character(VISIT_STIM)) %>% 
  left_join(cluster_names, by = "VISIT_STIM") #%>% 
  #select(-RNA_snn_res.0.6) #%>% 
  #pivot_wider(names_from = "cell_type", values_from = "Prop")

p_bar_cell <- test %>% 
  ggplot(aes(x = VISIT_STIM, y = Prop, fill = sctype_classification)) +
  geom_bar(aes(alpha = 0.8),
           stat = "summary",
           fun = "median",
           color = "black") +
  #facet_wrap(~ VISIT) +  # This creates separate plots for each VISIT value
  ylab("Proportion of cells") +
  xlab(NULL) +
  guides(alpha = "none",
         fill = guide_legend(override.aes = list(alpha = 0.8))) +
  ggpubr::theme_pubr(base_size = 20, legend = "bottom", x.text.angle = 90)

# Save the plot
cowplot::ggsave2(file.path(dir_save, 'p_bar_cell_STIM_sctype.png'), p_bar_cell,
                 units = 'cm',
                 width = 30,
                 height = 20)








###########################################
# Extract metadata
metadata <- obj@meta.data

# Get unique clusters and stimulation groups
clusters <- unique(metadata$seurat_clusters)
stim_groups <- unique(metadata$STIM)

# Initialize an empty list to store results
results_list <- list()

# Iterate over each stimulation group and cluster to calculate the metrics
for (stim in stim_groups) {
  for (cluster in clusters) {
    # Subset metadata for the current stim and cluster
    subset_metadata <- metadata %>% 
      filter(seurat_clusters == cluster, STIM == stim)
    
    # Calculate metrics
    mapped_reads <- mean(subset_metadata$reads.mapped, na.rm = TRUE)
    exon_reads <- mean(subset_metadata$ExonReads, na.rm = TRUE)
    intron_reads <- mean(subset_metadata$IntronReads, na.rm = TRUE)
    nTrans <- mean(subset_metadata$nCount_RNA, na.rm = TRUE)
    nGenes <- mean(subset_metadata$nFeature_RNA, na.rm = TRUE)
    percMito <- mean(subset_metadata$percent.mito, na.rm = TRUE)
    nCells <- nrow(subset_metadata)
    
    # Create a data frame with the calculated metrics
    metrics_df <- data.frame(
      Stimulation = stim,
      Cluster = cluster,
      MappedReads = mapped_reads,
      ExonReads = exon_reads,
      IntronReads = intron_reads,
      nTrans = nTrans,
      nGenes = nGenes,
      percMito = percMito,
      nCells = nCells
    )
    
    # Append the data frame to the results list
    results_list[[paste0("Cluster", cluster, "_Stim", stim)]] <- metrics_df
  }
}

# Combine all results into a single data frame
summary_table <- bind_rows(results_list, .id = "Cluster_Stim")

# Reshape the summary table to have clusters and stimulations as columns
summary_table_wide <- summary_table %>% 
  pivot_wider(names_from = Cluster_Stim, values_from = c(MappedReads, ExonReads, IntronReads, nTrans, nGenes, percMito, nCells))

# View the summary table
View(summary_table_wide)

```






### Identify conserved cell type markers

```{r}
#Idents(obj) <- "sctype_classification"

# Create a list of all sctype classifications in obj
# sctype.types <- levels(Idents(obj))

# Initialize a list to store cluster markers
#cluster.markers <- list()

# Loop through each Seurat cluster in obj

#for (sctype.type in sctype.types) {
  
  #sctype.markers <- FindConservedMarkers(obj, ident.1 = sctype.type, grouping.var = "group", verbose = FALSE)
  
  #
  
  # Identify differentially expressed genes
  
  
#}


```

### Overlay expression of ADTs on RNA clusters

```{r}
# Create a list of all cluster identities in obj
cluster.ids <- levels(Idents(obj))

# Initialize a list to store cluster markers
cluster.markers.RNAandADT <- list()

# Normalize the ADT data
DefaultAssay(obj) <- "ADT"
obj <- NormalizeData(obj, normalization.method = "CLR", margin = 2)

# Loop through each Seurat cluster in obj
for (cluster.id in cluster.ids) {
  
  # Find genes for RNA assay sorted by adjusted p value 
  genes_RNA <- FindMarkers(obj, ident.1 = cluster.id, assay = "RNA")
  genes_RNA <- rownames(genes_RNA[order(genes_RNA$p_val_adj), ])
  
  # Find genes for ADT assay sorted by adjusted p value 
  genes_ADT <- FindMarkers(obj, ident.1 = cluster.id, assay = "ADT")
  genes_ADT <- rownames(genes_ADT[order(genes_ADT$p_val_adj), ])
  
  # Find common genes between RNA and ADT assays
  cluster.markers.RNAandADT <- intersect(genes_RNA, genes_ADT)
  
  object.name <- paste0("cluster.markers.", cluster.id)

  # Plot violin plots of relative expression 
  DefaultAssay(obj) <- "RNA"
  vln_RNA <- VlnPlot(obj,
                      features = c(cluster.markers.RNAandADT)[1:10],
                      log = TRUE,
                      ncol = 1,
                      pt.size = 0) 
  main_title <- ggdraw() + 
  draw_label(paste0("RNA Cluster ", cluster.id), fontface = "bold", size = 14, hjust = 0.5)
  vln_RNA <- plot_grid(main_title, vln_RNA, nrow = 2, rel_heights = c(0.05, 0.95))


  DefaultAssay(obj) <- "ADT"
  vln_ADT <- VlnPlot(obj,
                      features = c(cluster.markers.RNAandADT)[1:10],
                      log = TRUE,
                      ncol = 1,
                      pt.size = 0)
  main_title <- ggdraw() + 
  draw_label(paste0("ADT Cluster ", cluster.id), fontface = "bold", size = 14, hjust = 0.5)
  vln_ADT <- plot_grid(main_title, vln_ADT, nrow = 2, rel_heights = c(0.05, 0.95))
  
  vln_plots <- paste0("Multimodal_DEG_VlnPlotRelExp_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, vln_plots), height = 30, width = 10)
  print(vln_RNA | vln_ADT)
  dev.off()
  
  # Plot feature plots overlaid onto UMAP
  
  DefaultAssay(obj) <- "RNA"
  feature_RNA <- FeaturePlot(obj,
                              features = c(cluster.markers.RNAandADT)[1:10],
                              label = TRUE,
                              label.size = 4,
                              ncol = 1,
                              pt.size = 0)
  main_title <- ggdraw() + 
  draw_label(paste0("RNA Cluster ", cluster.id), fontface = "bold", size = 14, hjust = 0.5)
  feature_RNA <- plot_grid(main_title, feature_RNA, nrow = 2, rel_heights = c(0.05, 0.95))
  
  DefaultAssay(obj) <- "ADT"
  feature_ADT <- FeaturePlot(obj,
                              features = c(cluster.markers.RNAandADT)[1:10],
                              label = TRUE,
                              label.size = 4,
                              ncol = 1,
                              pt.size = 0)
  main_title <- ggdraw() + 
  draw_label(paste0("ADT Cluster ", cluster.id), fontface = "bold", size = 14, hjust = 0.5)
  feature_ADT <- plot_grid(main_title, feature_ADT, nrow = 2, rel_heights = c(0.05, 0.95))
  
  feature_plots <- paste0("Multimodal_DEG_FeaturePlot_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, feature_plots), height = 30, width = 10)
  print(feature_RNA | feature_ADT)
  dev.off()
}
```

```{r}
save(obj, file = paste0(dir_save, "Seurat_ClusterIDCellsRNAonly_obj.Rdata"))
saveRDS(obj, file = paste0(dir_save, "Seurat_ClusterIDCellsRNAonly_obj.rds"))
```

## ADT (Protein)

### Set default assay to ADT

```{r}
DefaultAssay(obj) <- "ADT"
```

### Split the object into multiple layers for integration based on ADT Assay

```{r, warning = FALSE}
obj[["ADT"]] <- split(obj[["ADT"]], f = obj$RUN)
obj
```

### Normalize the ADT data

```{r, message = FALSE}
obj <- NormalizeData(obj, normalization.method = "CLR", margin = 2)
```

### Identify variable features

```{r, message = FALSE}
obj <- FindVariableFeatures(obj, selection.method = "vst")

# Identify the 10 most highly variable genes
top10.adt <- head(VariableFeatures(obj), 10)

# plot variable features and label top 10 variable features
plot3 <- VariableFeaturePlot(obj)
plot4 <-LabelPoints(plot = plot3, points = top10.adt, repel = TRUE)
plot4
```

### Scale the ADT data

```{r}
obj <- ScaleData(obj)
```

### Perform linear dimensional reduction

```{r}
# Perform PCA for linear dimensional reduction on scaled data. Give reduction a new name to avoid overwriting RNA reduction. 
obj <- RunPCA(obj, features = NULL, reduction.name = 'pca.adt') # VariableFeatures(object = obj)

# Examine and visualize PCA results a few different ways
print(obj[["pca.adt"]], dims = 1:5, nfeatures = 5)

VizDimLoadings(obj, dims = 1:2, reduction = "pca.adt")

DimPlot(obj, reduction = "pca.adt") + NoLegend()

DimHeatmap(obj, reduction = "pca.adt", dims = 1, cells = 500, balanced = TRUE)
```

```{r}
#| fig-height: 13

DimHeatmap(obj, reduction = "pca.adt", dims = 1:6, cells = 500, balanced = TRUE)
```

Determine the dimensionality of the dataset using an Elbow plot (more efficient alternative to JackStraw procedure).

```{r}
ElbowPlot(obj, reduction = "pca.adt")
```

### Cluster cells based on ADT

Start with standard Seurat clustering method WITHOUT INTEGRATION (using ElbowPlot output to determine dims).

```{r, message=FALSE}
obj <- FindNeighbors(obj, reduction = "pca.adt") # dims = 1:12
obj <- FindClusters(obj, cluster.name = "unintegrated_clusters_adt") # res = 1.2
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca.adt", reduction.name = "umap.unintegrated.adt")

DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("group", "seurat_clusters"))
```

```{r}
#| fig-height: 6.5

DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("STIM", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("PID", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("VISIT", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

### Perform integration of ADT Assay

```{r}
obj <- IntegrateLayers(object = obj, 
                       method = CCAIntegration, 
                       orig.reduction = "pca.adt", 
                       new.reduction = "integrated.cca.adt", 
                       verbose = FALSE)

obj[["ADT"]] <- JoinLayers(obj[["ADT"]])

obj <- FindNeighbors(obj, reduction = "integrated.cca.adt", dims = 1:30) 
obj <- FindClusters(obj, resolution = 1.2)

obj <- RunUMAP(obj, dims = 1:30, reduction = "integrated.cca.adt", reduction.name = "umap.adt") 

DimPlot(obj, reduction = "umap.adt", group.by = c("group", "seurat_clusters"))
```

```{r}
#| fig-height: 6.5

DimPlot(obj, reduction = "umap.adt", group.by = c("STIM", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = "umap.adt", group.by = c("PID", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = "umap.adt", group.by = c("VISIT", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = "umap.adt", group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

### Determine more accurate cluster resolution using clustree

```{r, message=FALSE}
#| fig-height: 13

resolution.range <- seq(from =0.2, to = 2, by = 0.2)
obj <- Seurat::FindClusters(object = obj, resolution = resolution.range)

clustree <- clustree(obj, prefix = "ADT_snn_res.")

pdf(paste0(dir_save, "clustree.all_adt.pdf"))
clustree
dev.off()

umap.0.4.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.0.4")
umap.0.6.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.0.6")
umap.0.8.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.0.8")
umap.1.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.1")
umap.1.2.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.1.2")

snn_all.adt <- (umap.0.4.adt | umap.0.6.adt) / (umap.0.8.adt | umap.1.adt) / umap.1.2.adt

pdf(paste0(dir_save, "umap_snn_compare_adt.pdf"), width = 20, height = 20)
snn_all.adt
dev.off()

snn_all.adt

Idents(object = obj) <- "ADT_snn_res.0.6"
```

### Visualize clusters

```{r, message=FALSE}
# Plot UMAPs
pdf(paste0(dir_save, "umap_res.0.6_adt.pdf"))
DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 6)
dev.off()
```

```{r}
#| fig-height: 6.5

pdf(paste0(dir_save, "umap_allHIVES_res.0.6_adt.pdf"), height = 6, width = 25)
DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "HIVE",
        repel = T)
dev.off()

pdf(paste0(dir_save, "umap_allPID_res.0.6_adt.pdf"), height = 6, width = 25)
DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "PID",
        repel = T)
dev.off()

pdf(paste0(dir_save, "umap_allSTIM_res.0.6_adt.pdf"), height = 6, width = 20)
DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "STIM",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
dev.off()

pdf(paste0(dir_save, "umap_allVISIT_res.0.6_adt.pdf"), height = 6, width = 20)
DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "VISIT",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
dev.off()

pdf(paste0(dir_save, "umap_allConditions_res.0.6_adt.pdf"), height = 6, width = 20)
DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = c("group", "STIM"),
        split.by = "VISIT",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
dev.off()

pdf(paste0(dir_save, "umap_allConditionsAlternative_res.0.6_adt.pdf"), height = 6, width = 20)
DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = c("VISIT", "STIM"),
        split.by = "group",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
dev.off()
```

### Determine marker expression by cluster

Find markers for every cell cluster compared to all remaining cells, report only the positive ones.

```{r, message=FALSE}
obj.markers.adt <- FindAllMarkers(obj, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)

obj.markers.adt %>%
  group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1)

write.csv(obj.markers.adt, file = file.path(dir_save, "all_markers_snn0.6_adt.csv"), quote = FALSE)
```

### Identify markers differentially expressed between specific clusters of interest and plot differentially expressed features as relative expression and as counts.

```{r, message=FALSE}

# Create a list of all cluster identities in obj
cluster.ids.adt <- levels(Idents(obj))

# Initialize a list to store cluster markers
cluster.markers.adt <- list()

# Loop through each Seurat cluster in obj

for (cluster.id in cluster.ids.adt) {
  
  # Find markers for the current cluster
  cluster.markers.adt <- FindMarkers(obj, ident.1 = cluster.id)
  
  # Assign a dynamic object name based on the cluster ID
  object.name <- paste0("cluster.markers", cluster.id)
  
  # Export cluster markers to a CSV file
  csv_file <- paste0(object.name, "_adt.csv")
  write.csv(cluster.markers.adt, file = file.path(dir_save, paste0(csv_file)), row.names = TRUE)
  
  # Plot expression of top 10 differentially expressed genes for the current cluster
   vln_plot.adt <- VlnPlot(obj,
          features = rownames(cluster.markers.adt)[1:10],
          ncol = 2,
          pt.size = 0)
  vln_plot_relexp.adt <- paste0("DEG_VlnPlotRelExp_Top10_", object.name, "_adt.pdf")
  pdf(paste0(dir_save, vln_plot_relexp.adt), height = 12, width = 6)
  print(vln_plot.adt)
  dev.off()
  
  vln_plot.adt <- VlnPlot(obj,
          features = rownames(cluster.markers.adt)[1:10],
          slot = "counts", 
          log = TRUE, 
          ncol = 2,
          pt.size = 0)
  vln_plot_counts.adt <- paste0("DEG_VlnPlotCounts_Top10_", object.name, "_adt.pdf")
  pdf(paste0(dir_save, vln_plot_counts.adt), height = 12, width = 6)
  print(vln_plot.adt)
  dev.off()
  
  feature_plot.adt <- FeaturePlot(obj,
            features = rownames(cluster.markers.adt)[1:10], 
            label = TRUE,
            label.size = 4,
            split.by = "group",
            pt.size = 0)
  feature_plots.adt <- paste0("DEG_FeaturePlot_Top10_", object.name, "_adt.pdf")
  pdf(paste0(dir_save, feature_plots.adt), height = 24, width = 6)
  print(feature_plot.adt)
  dev.off()
  
}

# Plot a heatmap to look at the top 10 differentially expressed genes across all clusters
pdf(paste0(dir_save, "DEG_Heatmap_AllClusters_Top10_adt.pdf"), height = 30, width = 20)
obj.markers.adt %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC) -> top10
DoHeatmap(obj, features = top10$gene) + NoLegend()
dev.off()

# Find all markers distinguishing an interesting cluster from main PBMC clusters
cluster1vPBMC.markers.adt <- FindMarkers(obj, ident.1 = 1, ident.2 = c(0, 2:11))
head(cluster1vPBMC.markers.adt, n = 10)
```

### Assign cell types

Predict cell types based on expression using sc-Type

```{r}
# Load gene set preparation function 
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")

# Load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")
```

Prepare gene sets from input cell marker file. This uses the default of in-built cell marker DB.

```{r}
# DB file
#db_ <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";

db_ <- "data/ScTypeDB_full_CYedit6.xlsx"
tissue <- "Immune system" # e.g. Immune system, Pancreas, Liver, Eye, Kidney, Brain, Lung, Adrenal, Heart, Intestine, Muscle, Placenta, Spleen, Stomach, Thymus 

# prepare gene sets
gs_list <- gene_sets_prepare(db_, tissue)
```

Run sc-Type.

```{r}

### CHANGE obj@meta.data$seurat_clusters TO Idents(obj)

# check Seurat object version (scRNA-seq matrix extracted differently in Seurat v4/v5)
seurat_package_v5 <- isFALSE('counts' %in% names(attributes(obj[["ADT"]])));
print(sprintf("Seurat object %s is used", ifelse(seurat_package_v5, "v5", "v4")))

# extract scaled scRNA-seq matrix
scRNAseqData_scaled.adt <- if (seurat_package_v5) as.matrix(obj[["ADT"]]$scale.data) else as.matrix(obj[["ADT"]]@scale.data)

# run ScType
es.max.adt <- sctype_score(scRNAseqData = scRNAseqData_scaled.adt, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# merge by cluster
cL_resutls.adt <- do.call("rbind", lapply(unique(obj@meta.data$seurat_clusters), function(cl){
  es.max.cl.adt = sort(rowSums(es.max.adt[ ,rownames(obj@meta.data[obj@meta.data$seurat_clusters==cl, ])]), decreasing = !0)
  head(data.frame(cluster = cl, type = names(es.max.cl.adt), scores = es.max.cl.adt, ncells = sum(obj@meta.data$seurat_clusters==cl)), 10)
}))
sctype_scores.adt <- cL_resutls.adt %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores.adt$type[as.numeric(as.character(sctype_scores.adt$scores)) < sctype_scores.adt$ncells/4] <- "Unknown"
print(sctype_scores.adt[,1:3])
```

Overlay cell type IDs on UMAP.

```{r}
obj@meta.data$sctype_classification.adt = NA
for(j in unique(sctype_scores.adt$cluster)){
  cl_type = sctype_scores.adt[sctype_scores.adt$cluster==j,]; 
  obj@meta.data$sctype_classification.adt[obj@meta.data$seurat_clusters == j] = as.character(cl_type$type[1])
}

pdf(paste0(dir_save, "umap_annotated_adt.pdf"), height = 7, width = 10)
umap_annotated_adt <- DimPlot(obj, reduction = "umap.adt", label = TRUE, repel = TRUE, group.by = 'sctype_classification.adt')
print(umap_annotated_adt)
invisible(dev.off())
umap_annotated_adt
```

```{r}
#| fig-height: 6.5

pdf(paste0(dir_save, "umap_annotated_splitgroup_adt.pdf"), height = 7, width = 15)
umap_annotated_adt_group <- DimPlot(obj, reduction = "umap.adt", split.by = "group", group.by = 'sctype_classification.adt')
print(umap_annotated_adt_group)
invisible(dev.off())
umap_annotated_adt_group
```

## Multimodal

### Identify multimodal neighbors

```{r}
obj <- FindMultiModalNeighbors(
  obj, reduction.list = list("pca", "pca.adt"), 
  dims.list = list(1:30, 1:18), modality.weight.name = "RNA.weight"
)
```

### Cluster and plot based on RNA and ADT assays

```{r}
obj <- RunUMAP(obj, nn.name = "weighted.nn", reduction.name = "wnn.umap", reduction.key = "wnnUMAP_")
obj <- FindClusters(obj, graph.name = "wsnn", algorithm = 3, resolution = 2, verbose = FALSE)

DimPlot(obj, reduction = 'wnn.umap', group.by = c("group", "seurat_clusters"))
```

```{r}
#| fig-height: 6.5

DimPlot(obj, reduction = 'wnn.umap', group.by = c("STIM", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = 'wnn.umap', group.by = c("PID", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = 'wnn.umap', group.by = c("VISIT", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = 'wnn.umap', group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

### Overlay ADT expression over RNA-clustered UMAP.

```{r}

```

### Save Rdata and rds

```{r}
save(obj, file = paste0(dir_save, "Seurat_ClusterIDCells_obj.Rdata"))
saveRDS(obj, file = paste0(dir_save, "Seurat_ClusterIDcells_obj.rds"))
```
