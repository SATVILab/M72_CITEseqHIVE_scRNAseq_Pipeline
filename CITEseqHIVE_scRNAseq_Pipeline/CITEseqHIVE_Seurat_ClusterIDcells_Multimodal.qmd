---
title: "CITEseq-HIVE Seurat Cluster and ID cell types with Multimodal Data"
format:
  html:
        code-fold: true
editor: visual
---

## Description

This script takes the output of CITEseqHIVE_Seurat_FilterMergeQC.qmd as input. Each Assay ("RNA", and "ADT") will be processed individually first, and then integrated using Weighted Nearest Neighbors (WNN) for combined analysis. Analysis in this script includes normalization and scaling, clustering, and cell type identification.

### Clear console

```{r, output = FALSE}
ls()
rm(list=ls())
```

### Set output directory

```{r}
dir_save <- "output/dataset_full/"
```

### Load libraries

```{r, message = FALSE, warning = FALSE}
library(SingleCellExperiment)
library(Seurat)
library(SeuratObject)
library(tidyr)
library(dplyr)
library(clustree)
library(ggpubr)
library(patchwork)
library(reshape2)
library(RColorBrewer)
library(magrittr)
library(HGNChelper)
library(celldex)
library(SingleR)
library(openxlsx)
library(multtest)
library(metap)
library(ggplot2)
library(cowplot)
library(readxl)
library(devtools)
library(presto)
library(kableExtra)
library(glue)
library(Nebulosa)
library(grid)
library(gridExtra)
```

## RNA

Begin by processing the "RNA" assay. In the below section, only RNA expression data will be considered when performing normalization, scaling, clustering, and cell identification steps. ADT data is ignored.

### Load the filtered, merged, .Rdata object and examine structure

The Seurat_FilterMerge_obj.Rdata file generated by CITEseqHIVE_Seurat_FilterMergeQC.qmd serves as input for this pipeline. It should contain only one object, called "obj" which is the filtered and merged Seruat object for all CITEseq-HIVE plates.

```{r}
load("output/dataset_full/Seurat_FilterMerge_obj.Rdata")
obj

# Confirm Seruat object contains assays for RNA and ADT
Assays(obj)
```

### Split the object into multiple layers for integration based on the RNA Assay

Integration is performed to account for batch effects. Therefore, the factor used to split the object into multiple layers should be the factor that provides information on which batch the samples came from. In this case, each batch has a unique RUN ID. The metadata column for that contains the RUN IDs is called "RUN" and should be used to integrate layers.

Because this Seurat object contains RNA, HTO, and ADT assays, we will perform integration separately beginning with the RNA assay.

```{r, warning = FALSE}
obj[["RNA"]] <- split(obj[["RNA"]], f = obj$RUN)
obj
```

### Show QC metrics for the first 5 cells and create a metadata object

This is intended to give a snapshot look at some QC metrics and metadata features that can be used for downstream analysis.

```{r}
head(obj@meta.data, 5) %>% 
  kbl() %>% 
  kable_styling()

metadata <- obj@meta.data
```

### Normalize the RNA data

As this dataset contains only an RNA assay we use standard Seurat NormalizeData function to perform log normalization with a scale factor of 10000.

```{r, message = FALSE}
obj <- NormalizeData(obj, normalization.method = "LogNormalize", scale.factor = 10000) 
```

### Identify variable features

We select the top 2000 variable features for downstream analyses using the standard Seurat FindVariableFeatures function with selection method "vst".

```{r, message = FALSE, warning = FALSE}
# Calculate the top 2000 highly variable features
obj <- FindVariableFeatures(obj, selection.method = "vst", nfeatures = 2000) 

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(obj), 10)

# plot variable features and label top 10 variable features
plot1 <- VariableFeaturePlot(obj)
plot2 <-LabelPoints(plot = plot1, points = top10, repel = TRUE)
```

```{r, echo = FALSE, warning = FALSE}
print(plot2)
```

### Scale the RNA data

Data is scaled using only variable features by default.

```{r, message = FALSE}
# Use defaults to scale only variable features 
obj <- ScaleData(obj) 
```

### Perform linear dimensional reduction

Principal component analysis (PCA) is used for linear dimensional reduction of scaled data. PCA is run with default options. The plots below visualize dimensional reduction genes for principal components (PC) 1 and 2, display cell positioning in 2D, and a heatmap of genes associated with the top 1 and 15 PCs for all cells.

```{r, output = FALSE}
# Perform PCA for linear dimensional reduction on scaled data
obj <- RunPCA(obj, features = NULL) 

# Examine and visualize PCA results a few different ways

plot1 <- VizDimLoadings(obj, dims = 1:2, reduction = "pca")

plot2 <- DimPlot(obj, reduction = "pca") + NoLegend()

plot3 <- DimHeatmap(obj, dims = 1, cells = 500, balanced = TRUE)

plot4 <- DimHeatmap(obj, dims = 1:15, cells = 500, balanced = TRUE)
```

```{r, echo = FALSE}
print(plot1)
print(plot2)
DimHeatmap(obj, dims = 1, cells = 500, balanced = TRUE)
```

```{r, echo = FALSE}
#| fig-height: 19.5
DimHeatmap(object = obj, dims = 1:15, cells = 500, balanced = TRUE) 
```

### Examine variance explained by each principal component

Here we look at the variance in the dataset that is explained by each individual PC and at the cumulative variance explained by the PCs.

We also determine the dimensionality of the dataset using an Elbow plot (more efficient alternative to JackStraw procedure).

```{r}
pca = obj[["pca"]]

# Get the eigenvalues
evs = pca@stdev^2
total.var = pca@misc$total.variance
varExplained = evs/total.var
pca.data = data.frame(PC=factor(1:length(evs)),
                      percVar=varExplained*100)
pca.data$cumulVar = cumsum(pca.data$percVar)

head(pca.data, 20)

scPlot1 <- pca.data[1:10,] %>%
          ggplot(aes(x=PC, y=percVar)) +
          geom_bar(stat='identity') +
          geom_hline(yintercept = 1, colour="red", linetype=3) +
          labs(title="Variance Explanation by PCA") +
          xlab("Principal Components") +
          ylab("Percentage of Explained Variance") +
          theme_bw()

scPlot2 <- pca.data[1:10,] %>%
          ggplot(aes(x=PC, y=cumulVar)) +
          geom_bar(stat='identity') +
          geom_hline(yintercept = 50, colour="red", linetype=3) +
          labs(title="Cumulative Variance Explanation by PCA") +
          xlab("Principal Components") +
          ylab("Cumulative Percentage of Explained Variance") +
          theme_bw()

elbow <- ElbowPlot(obj)
```

```{r, echo = FALSE}
print(scPlot1)
print(scPlot2)
print(elbow)
```

### Cluster cells based on RNA

Start with standard Seurat clustering method WITHOUT INTEGRATION. Use the bar and Elbow plots to determine minimum dimensions to use for clustering. Clustering is performed using UMAP for non-linear dimensional reduction. The number of dimensions is set to 30. PCA is used to find neighbors and clusters and for UMAP reduction.

The tabulated plots visualize the basic UMAP with seurat clusters for all cells and conditions as well as UMAPs grouped by metadata features and split by group.

```{r, message = FALSE, warning = FALSE}
obj <- FindNeighbors(obj, reduction = "pca")
obj <- FindClusters(obj, cluster.name = "unintegrated_clusters")
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca", reduction.name = "umap.unintegrated")

plot1 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("unintegrated_clusters"), split.by = "group", label = TRUE, label.size = 6)
plot2 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("RUN"), split.by = "group")
plot3 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("PID"), split.by = "group")
plot4 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("VISIT"), split.by = "group")
plot5 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("VISIT_group"))
plot6 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("STIM"), split.by = "group")
plot7 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("VISIT_STIM"), split.by = "group")
plot8 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("VISIT_STIM_group"))
plot9 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("unintegrated_clusters"), label = TRUE, label.size = 6)
```

::: panel-tabset
## UMAP group

```{r, echo = FALSE}
print(plot1)
```

## UMAP RUN

```{r, echo = FALSE}
#| fig-height: 10
print(plot2 / plot9)
```

## UMAP PID

```{r, echo = FALSE}
#| fig-height: 10
print(plot3 / plot9)
```

## UMAP VISIT

```{r, echo = FALSE}
#| fig-height: 10
print(plot4 / plot9)
```

## UMAP VISIT & group

```{r, echo = FALSE}
#| fig-height: 10
print(plot5 / plot9)
```

## UMAP STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot6 / plot9)
```

## UMAP VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot7 / plot9)
```

## UMAP VISIT & STIM & group

```{r, echo = FALSE}
#| fig-height: 10
print(plot8 / plot9)
```
:::

### Inspect cluster proportions on unintegrated clusters

Next we examine the proportion of each cluster that is comprised of cells with key metadata features: RUN, group, STIM, PID, and VISIT. Proportions are shown alongside total cell number per cluster.

```{r, warning = FALSE, message = FALSE}
plot_unintegrated_clusters = function (srat, batchcolumn) {
  ## take an integrated Seurat object, plot distributions over orig.ident

  count_table <- table(srat@meta.data$unintegrated_clusters, srat@meta.data[[batchcolumn]])
  count_mtx   <- as.data.frame.matrix(count_table)
  count_mtx$cluster <- rownames(count_mtx)
  melt_mtx    <- melt(count_mtx)
  melt_mtx$cluster <- as.factor(melt_mtx$cluster)

  cluster_size   <- aggregate(value ~ cluster, data = melt_mtx, FUN = sum)

  sorted_labels <- paste(sort(as.integer(levels(cluster_size$cluster)),decreasing = T))
  cluster_size$cluster <- factor(cluster_size$cluster,levels = sorted_labels)
  melt_mtx$cluster <- factor(melt_mtx$cluster,levels = sorted_labels)

  colnames(melt_mtx)[2] <- "dataset"


  p1 <- ggplot(cluster_size, aes(y= cluster,x = value)) + geom_bar(position="dodge", stat="identity",fill = "grey60") +
    geom_text(aes(label=value), hjust=1.5, size=3) +
    theme_bw() + scale_x_log10() + xlab("Cells per cluster, log10 scale") + ylab("")
  p2 <- ggplot(melt_mtx,aes(x=cluster,y=value,fill=dataset)) +
    geom_bar(position="fill", stat="identity") + theme_bw() + coord_flip() +
    #scale_fill_brewer(palette = "Set2") +
    ylab("Fraction of cells in each dataset") + xlab("Cluster number") + theme(legend.position="left")

  p2 + p1 + plot_layout(widths = c(3,2))
}


plot1 <- plot_unintegrated_clusters(obj, 'group')
plot2 <- plot_unintegrated_clusters(obj, 'RUN')
plot3 <- plot_unintegrated_clusters(obj, 'PID')
plot4 <- plot_unintegrated_clusters(obj, 'VISIT')
plot5 <- plot_unintegrated_clusters(obj, 'VISIT_group')
plot6 <- plot_unintegrated_clusters(obj, 'STIM')
plot7 <- plot_unintegrated_clusters(obj, 'VISIT_STIM')
plot8 <- plot_unintegrated_clusters(obj, 'VISIT_STIM_group')
```

::: panel-tabset
## Proportions group

```{r, echo = FALSE}
#| fig-height: 5
print(plot1)
```

## Proportions RUN

```{r, echo = FALSE}
#| fig-height: 5
print(plot2)
```

## Proportions PID

```{r, echo = FALSE}
#| fig-height: 5
print(plot3)
```

## Proportions VISIT

```{r, echo = FALSE}
#| fig-height: 5
print(plot4)
```

## Proportions VISIT & group

```{r, echo = FALSE}
#| fig-height: 5
print(plot5)
```

## Proportions STIM

```{r, echo = FALSE}
#| fig-height: 5
print(plot6)
```

## Proportions VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 5
print(plot7)
```

## Proportions VISIT & STIM & group

```{r, echo = FALSE}
#| fig-height: 5
print(plot8)
```
:::

### Perform integration of RNA Assay

Integration is performed using the RUN metadata variable. Each RUN is representative of a single experimental processing batch which includes samples from two PIDs at both time points. Each RUN therefore can be seen as an individual batch and can be used in integration to adjust for experimentally-introduced batch effects.

```{r, message = FALSE, warning = FALSE}
obj <- IntegrateLayers(object = obj, 
                       method = CCAIntegration, 
                       orig.reduction = "pca", 
                       new.reduction = "integrated.cca", 
                       verbose = FALSE)

obj[["RNA"]] <- JoinLayers(obj[["RNA"]])

obj <- FindNeighbors(obj, reduction = "integrated.cca", dims = 1:30) 
obj <- FindClusters(obj, resolution = 1.2)

obj <- RunUMAP(obj, dims = 1:30, reduction = "integrated.cca") 

plot1 <- DimPlot(obj, reduction = "umap", group.by = c("seurat_clusters"), split.by = "group", label = TRUE, label.size = 6)
plot2 <- DimPlot(obj, reduction = "umap", group.by = c("RUN"), split.by = "group")
plot3 <- DimPlot(obj, reduction = "umap", group.by = c("PID"), split.by = "group")
plot4 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT"), split.by = "group")
plot5 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_group"))
plot6 <- DimPlot(obj, reduction = "umap", group.by = c("STIM"), split.by = "group")
plot7 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_STIM"), split.by = "group")
plot8 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_STIM_group"))
plot9 <- DimPlot(obj, reduction = "umap", group.by = c("seurat_clusters"), label = TRUE, label.size = 6)

# Add columns for metadata converted to numeric format for Nebulosa density plot
obj$VISIT_numeric <- ifelse(obj$VISIT == "D37", 1, 0)
obj$STIM_numeric <- ifelse(obj$STIM == "M72", 1, 0)
obj$VISIT_STIM_numeric <- ifelse(obj$VISIT_STIM == "D37 M72", 1, 0)
obj$VISIT_STIM_group_numeric <- ifelse(obj$VISIT_STIM == "D37 M72 Vaccinee", 1, 0)

plot10 <- plot_density(obj, features = "VISIT_numeric", reduction = "umap")
plot11 <- plot_density(obj, features = "STIM_numeric", reduction = "umap")
plot12 <- plot_density(obj, features = "VISIT_STIM_numeric", reduction = "umap")
```

### Save integrated Seurat object as Rdata and rds

```{r}
save(obj, file = paste0(dir_save, "Seurat_ClusterIDCells_obj_IntegratedIntermediate.Rdata"))
saveRDS(obj, file = paste0(dir_save, "Seurat_ClusterIDcells_obj_IntegratedIntermediate.rds"))
```

### Plot integrated clusters

::: panel-tabset
## UMAP group

```{r, echo = FALSE}
print(plot1)
```

## UMAP RUN

```{r, echo = FALSE}
#| fig-height: 10
print(plot2 / plot9)
```

## UMAP PID

```{r, echo = FALSE}
#| fig-height: 10
print(plot3 / plot9)
```

## UMAP VISIT

```{r, echo = FALSE}
#| fig-height: 10
print(plot4 / plot9)
```

## UMAP VISIT & group

```{r, echo = FALSE}
#| fig-height: 10
print(plot5 / plot9)
```

## UMAP STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot6 / plot9)
```

## UMAP VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot7 / plot9)
```

## UMAP VISIT & STIM & group

```{r, echo = FALSE}
#| fig-height: 10
print(plot8 / plot9)
```
:::

### Plot cell densities for conditions over integrated UMAPs

::: panel-tabset
## Density VISIT

```{r, echo = FALSE}
#| fig-height: 10
print(plot10 / plot9)
```

## Density STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot11 / plot9)
```

## Density VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot12 / plot9)
```
:::

### Inspect RUN metrics on integrated clusters

Now that integration is complete, we will re-examine the proportion of each cluster that is comprised of cells with key metadata features: RUN, group, PID, VISIT, and STIM. Proportions are shown alongside total cell number per cluster. Compare these outputs to those above for unintegrated clusters to determine how cluster composition was changed by integration.

```{r, warning = FALSE, message = FALSE }
plot_integrated_clusters = function (srat, batchcolumn) {
  ## take an integrated Seurat object, plot distributions over orig.ident

  count_table <- table(srat@meta.data$seurat_clusters, srat@meta.data[[batchcolumn]])
  count_mtx   <- as.data.frame.matrix(count_table)
  count_mtx$cluster <- rownames(count_mtx)
  melt_mtx    <- melt(count_mtx)
  melt_mtx$cluster <- as.factor(melt_mtx$cluster)

  cluster_size   <- aggregate(value ~ cluster, data = melt_mtx, FUN = sum)

  sorted_labels <- paste(sort(as.integer(levels(cluster_size$cluster)),decreasing = T))
  cluster_size$cluster <- factor(cluster_size$cluster,levels = sorted_labels)
  melt_mtx$cluster <- factor(melt_mtx$cluster,levels = sorted_labels)

  colnames(melt_mtx)[2] <- "dataset"


  p1 <- ggplot(cluster_size, aes(y= cluster,x = value)) + geom_bar(position="dodge", stat="identity",fill = "grey60") +
    geom_text(aes(label=value), hjust=1.5, size=3) +
    theme_bw() + scale_x_log10() + xlab("Cells per cluster, log10 scale") + ylab("")
  p2 <- ggplot(melt_mtx,aes(x=cluster,y=value,fill=dataset)) +
    geom_bar(position="fill", stat="identity") + theme_bw() + coord_flip() +
    #scale_fill_brewer(palette = "Set2") +
    ylab("Fraction of cells in each dataset") + xlab("Cluster number") + theme(legend.position="left")

  p2 + p1 + plot_layout(widths = c(3,2))
}

plot1 <- plot_integrated_clusters(obj, 'group')
plot2 <- plot_integrated_clusters(obj, 'RUN')
plot3 <- plot_integrated_clusters(obj, 'PID')
plot4 <- plot_integrated_clusters(obj, 'VISIT')
plot5 <- plot_integrated_clusters(obj, 'VISIT_group')
plot6 <- plot_integrated_clusters(obj, 'STIM')
plot7 <- plot_integrated_clusters(obj, 'VISIT_STIM')
plot8 <- plot_integrated_clusters(obj, 'VISIT_STIM_group')
```

::: panel-tabset
## Proportions group

```{r, echo = FALSE}
#| fig-height: 5
print(plot1)
```

## Proportions RUN

```{r, echo = FALSE}
#| fig-height: 5
print(plot2)
```

## Proportions PID

```{r, echo = FALSE}
#| fig-height: 5
print(plot3)
```

## Proportions VISIT

```{r, echo = FALSE}
#| fig-height: 5
print(plot4)
```

## Proportions VISIT & group

```{r, echo = FALSE}
#| fig-height: 5
print(plot5)
```

## Proportions STIM

```{r, echo = FALSE}
#| fig-height: 5
print(plot6)
```

## Proportions VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 5
print(plot7)
```

## Proportions VISIT & STIM & group

```{r, echo = FALSE}
#| fig-height: 5
print(plot8)
```
:::

### Determine more accurate cluster resolution using clustree

Iterating through different resolutions using the clustree package can help determine what resolution best fits the data so that it can be used for downstream analyses. Using clustree, we iterate the clustering algorithm over a resolution range of 0.2 - 2, increasing by 0.2 with each round. We then plot the UMAPs for a representative selection of these iterations to determine what resolution to select moving forward.

```{r, message = FALSE, output = FALSE}
#| fig-height: 13

resolution.range <- seq(from =0.2, to = 2, by = 0.2)
obj <- Seurat::FindClusters(object = obj, resolution = resolution.range)

clustree <- clustree(obj, prefix = "RNA_snn_res.")

pdf(paste0(dir_save, "clustree.all.pdf"))
clustree_plot <- clustree
print(clustree_plot)
invisible(dev.off())
clustree_plot

umap.0.4 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.0.4")
umap.0.6 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.0.6")
umap.0.8 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.0.8")
umap.1 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.1")
umap.1.2 <- DimPlot(obj, reduction = "umap", label = T, group.by = "RNA_snn_res.1.2")

snn_all <- (umap.0.4 | umap.0.6) / (umap.0.8 | umap.1) / umap.1.2

pdf(paste0(dir_save, "umap_snn_compare.pdf"), width = 20, height = 20)
snn_all
invisible(dev.off())
```

```{r, echo = FALSE}
#| fig-height: 13

print(snn_all)
```

### Save cluster-refined Seurat object as Rdata and rds

```{r}
save(obj, file = paste0(dir_save, "Seurat_ClusterIDCells_obj_ClustreeIntermediate.Rdata"))
saveRDS(obj, file = paste0(dir_save, "Seurat_ClusterIDcells_obj_ClustreeIntermediate.rds"))
```

### Visualize clusters

Based on the clustree analysis, the optimal resolution for this dataset is 1.2.We set cluster identities to those associated with resolution = 1.2 and use these identities for further analysis.

```{r, message=FALSE, warning = FALSE}
# Select which resolution to use based on clustree analysis and assign optimal cluster IDs to Idents
Idents(object = obj) <- "RNA_snn_res.0.6"
refined_res <- "RNA_snn_res.0.6"

# Plot UMAP
pdf(paste0(dir_save, "umap_res.clustree.pdf"))
plot1 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
print(plot1)
invisible(dev.off())

# Plot Feature plot to ensure clustering is not driven by QC artifacts
pdf(paste0(dir_save, "umap_res.clustree_QC.pdf"))
QC_feature <- FeaturePlot(obj, features = c("nCount_RNA", "nFeature_RNA", "percent.mito", "Complexity"))
print(QC_feature)
invisible(dev.off())
```

```{r, echo = FALSE}
print(plot1)
print(QC_feature)
```

```{r, message=FALSE, warning = FALSE}
plot1 <- DimPlot(obj, reduction = "umap", group.by = c(refined_res), split.by = "group", label = TRUE, label.size = 6)
plot2 <- DimPlot(obj, reduction = "umap", group.by = c("RUN"), split.by = "group")
plot3 <- DimPlot(obj, reduction = "umap", group.by = c("PID"), split.by = "group")
plot4 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT"), split.by = "group")
plot5 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_group"))
plot6 <- DimPlot(obj, reduction = "umap", group.by = c("STIM"), split.by = "group")
plot7 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_STIM"), split.by = "group")
plot8 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_STIM_group"))
plot9 <- DimPlot(obj, reduction = "umap", group.by = c(refined_res), label = TRUE, label.size = 6)

pdf(paste0(dir_save, "umap_group_res.clustree.pdf"), height = 5, width = 10)
print(plot1)
invisible(dev.off())

pdf(paste0(dir_save, "umap_RUN_res.clustree.pdf"), height = 5, width = 10)
print(plot2)
invisible(dev.off())

pdf(paste0(dir_save, "umap_PID_res.clustree.pdf"), height = 5, width = 10)
print(plot3)
invisible(dev.off())

pdf(paste0(dir_save, "umap_VISIT_res.clustree.pdf"), height = 5, width = 10)
print(plot4)
invisible(dev.off())

pdf(paste0(dir_save, "umap_VISITgroup_res.clustree.pdf"), height = 5, width = 10)
print(plot5)
invisible(dev.off())

pdf(paste0(dir_save, "umap_STIM_res.clustree.pdf"), height = 5, width = 10)
print(plot6)
invisible(dev.off())

pdf(paste0(dir_save, "umap_VISITSTIM_res.clustree.pdf"), height = 5, width = 10)
print(plot7)
invisible(dev.off())

pdf(paste0(dir_save, "umap_VISITSTIMgroup_res.clustree.pdf"), height = 5, width = 10)
print(plot8)
invisible(dev.off())

pdf(paste0(dir_save, "umap_refinedclusters_res.clustree.pdf"), height = 5, width = 10)
print(plot9)
invisible(dev.off())


plot10 <- plot_density(obj, features = "VISIT_numeric", reduction = "umap")
plot11 <- plot_density(obj, features = "STIM_numeric", reduction = "umap")
plot12 <- plot_density(obj, features = "VISIT_STIM_numeric", reduction = "umap")

pdf(paste0(dir_save, "umap_densityVISIT_res.clustree.pdf"), height = 5, width = 10)
print(plot10)
invisible(dev.off())

pdf(paste0(dir_save, "umap_densitySTIM_res.clustree.pdf"), height = 5, width = 10)
print(plot11)
invisible(dev.off())

pdf(paste0(dir_save, "umap_densityVISITSTIM_res.clustree.pdf"), height = 5, width = 10)
print(plot12)
invisible(dev.off())
```

::: panel-tabset
## UMAP group

```{r, echo = FALSE}
print(plot1)
```

## UMAP RUN

```{r, echo = FALSE}
#| fig-height: 10
print(plot2 / plot9)
```

## UMAP PID

```{r, echo = FALSE}
#| fig-height: 10
print(plot3 / plot9)
```

## UMAP VISIT

```{r, echo = FALSE}
#| fig-height: 10
print(plot4 / plot9)
```

## UMAP VISIT & group

```{r, echo = FALSE}
#| fig-height: 10
print(plot5 / plot9)
```

## UMAP STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot6 / plot9)
```

## UMAP VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot7 / plot9)
```

## UMAP VISIT & STIM & group

```{r, echo = FALSE}
#| fig-height: 10
print(plot8 / plot9)
```
:::

### Plot cell densities for conditions over integrated UMAPs

::: panel-tabset
## Density VISIT

```{r, echo = FALSE}
#| fig-height: 10
print(plot10 / plot9)
```

## Density STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot11 / plot9)
```

## Density VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot12 / plot9)
```
:::

### Inspect cluster proportions on refined clusters

Now that cluster refinement is complete, we will re-examine the proportion of each cluster that is comprised of cells with key metadata features: RUN, group, PID, and VISIT. Proportions are shown alongside total cell number per cluster. Compare these outputs to those above for integrated clusters to determine how cluster composition was changed by refining cluster resolution.

```{r, warning = FALSE, message = FALSE}
plot_refined_clusters = function (srat, batchcolumn) {
  ## take an integrated Seurat object, plot distributions over orig.ident

  count_table <- table(srat@meta.data[[refined_res]], srat@meta.data[[batchcolumn]])
  count_mtx   <- as.data.frame.matrix(count_table)
  count_mtx$cluster <- rownames(count_mtx)
  melt_mtx    <- melt(count_mtx)
  melt_mtx$cluster <- as.factor(melt_mtx$cluster)

  cluster_size   <- aggregate(value ~ cluster, data = melt_mtx, FUN = sum)

  sorted_labels <- paste(sort(as.integer(levels(cluster_size$cluster)),decreasing = T))
  cluster_size$cluster <- factor(cluster_size$cluster,levels = sorted_labels)
  melt_mtx$cluster <- factor(melt_mtx$cluster,levels = sorted_labels)

  colnames(melt_mtx)[2] <- "dataset"


  p1 <- ggplot(cluster_size, aes(y= cluster,x = value)) + geom_bar(position="dodge", stat="identity",fill = "grey60") +
    geom_text(aes(label=value), hjust=1.5, size=3) +
    theme_bw() + scale_x_log10() + xlab("Cells per cluster, log10 scale") + ylab("")
  p2 <- ggplot(melt_mtx,aes(x=cluster,y=value,fill=dataset)) +
    geom_bar(position="fill", stat="identity") + theme_bw() + coord_flip() +
    #scale_fill_brewer(palette = "Set2") +
    ylab("Fraction of cells in each dataset") + xlab("Cluster number") + theme(legend.position="left")

  p2 + p1 + plot_layout(widths = c(3,2))
}

plot1 <- plot_refined_clusters(obj, 'group')
plot2 <- plot_refined_clusters(obj, 'RUN')
plot3 <- plot_refined_clusters(obj, 'PID')
plot4 <- plot_refined_clusters(obj, 'VISIT')
plot5 <- plot_refined_clusters(obj, 'VISIT_group')
plot6 <- plot_refined_clusters(obj, 'STIM')
plot7 <- plot_refined_clusters(obj, 'VISIT_STIM')
plot8 <- plot_refined_clusters(obj, 'VISIT_STIM_group')

pdf(paste0(dir_save, "prop_group_res.clustree.pdf"), height = 5, width = 10)
print(plot1)
invisible(dev.off())

pdf(paste0(dir_save, "prop_RUN_res.clustree.pdf"), height = 5, width = 10)
print(plot2)
invisible(dev.off())

pdf(paste0(dir_save, "prop_PID_res.clustree.pdf"), height = 5, width = 10)
print(plot3)
invisible(dev.off())

pdf(paste0(dir_save, "prop_VISIT_res.clustree.pdf"), height = 5, width = 10)
print(plot4)
invisible(dev.off())

pdf(paste0(dir_save, "prop_VISITgroup_res.clustree.pdf"), height = 5, width = 10)
print(plot5)
invisible(dev.off())

pdf(paste0(dir_save, "prop_STIM_res.clustree.pdf"), height = 5, width = 10)
print(plot6)
invisible(dev.off())

pdf(paste0(dir_save, "prop_VISITSTIM_res.clustree.pdf"), height = 5, width = 10)
print(plot7)
invisible(dev.off())

pdf(paste0(dir_save, "prop_VISITSTIMgroup_res.clustree.pdf"), height = 5, width = 10)
print(plot8)
invisible(dev.off())
```

::: panel-tabset
## Proportions group

```{r, echo = FALSE}
#| fig-height: 5
print(plot1)
```

## Proportions RUN

```{r, echo = FALSE}
#| fig-height: 5
print(plot2)
```

## Proportions PID

```{r, echo = FALSE}
#| fig-height: 5
print(plot3)
```

## Proportions VISIT

```{r, echo = FALSE}
#| fig-height: 5
print(plot4)
```

## Proportions VISIT & group

```{r, echo = FALSE}
#| fig-height: 5
print(plot5)
```

## Proportions STIM

```{r, echo = FALSE}
#| fig-height: 5
print(plot6)
```

## Proportions VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 5
print(plot7)
```

## Proportions VISIT & STIM & group

```{r, echo = FALSE}
#| fig-height: 5
print(plot8)
```
:::

To explore how clustering differs for various metadata features, we plot the optimized UMAP and group and split by features of interest.

```{r}
pdf(paste0(dir_save, "umap_allRUN_res.clustree.pdf"), height = 6, width = 25)
plot1 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "RUN",
        repel = T,
        ncol = 2)
print(plot1)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allHIVES_res.clustree.pdf"), height = 6, width = 25)
plot2 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "HIVE",
        repel = T,
        ncol = 2)
print(plot2)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allPID_res.clustree.pdf"), height = 6, width = 25)
plot3 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "PID",
        repel = T, 
        ncol = 2)
print(plot3)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allSTIM_res.clustree.pdf"), height = 6, width = 20)
plot4 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "STIM",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot4)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allVISIT_res.clustree.pdf"), height = 6, width = 20)
plot5 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "VISIT",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot5)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allConditions_res.clustree.pdf"), height = 12, width = 20)
plot6 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = c("group", "STIM"),
        split.by = "VISIT",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot6)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allConditionsAlternative_res.clustree.pdf"), height = 12, width = 10)
plot7 <- DimPlot(obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4,
        group.by = c("VISIT", "STIM"),
        split.by = "group",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot7)
invisible(dev.off())
```

::: panel-tabset
## RUN

```{r, echo = FALSE}
#| fig-height: 19

print(plot1)
```

## HIVEs

```{r, echo = FALSE}
#| fig-height: 19

print(plot2)
```

## PID

```{r, echo = FALSE}
#| fig-height: 32

print(plot3)
```

## STIM

```{r, echo = FALSE}
print(plot4)
```

## VISIT

```{r, echo = FALSE}
print(plot5)
```

## PID & VISIT

```{r, echo = FALSE}
#| fig-height: 9.5

print(plot6)
```

## PID & VISIT Alternative

```{r, echo = FALSE}
#| fig-height: 9.5

print(plot7)
```
:::

### Determine marker expression by cluster

Find markers for every cell cluster compared to all remaining cells, report only the positive ones. Save a .csv file that contains the markers for each cluster.

```{r, message = FALSE, output = FALSE}
obj.markers <- FindAllMarkers(obj, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)

obj.markers %>%
  group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1)

write.csv(obj.markers, file = file.path(dir_save, "all_markers_snn.clustree.csv"), quote = FALSE)
```

### Examine differential expression in clusters

Identify markers differentially expressed between specific clusters of interest and plot differentially expressed features as relative expression and as counts.

```{r, message = FALSE, warning = FALSE, output = FALSE}
# Function to create relative expression violin plots 
create_vln_rel <- function(obj) {

  # Plot expression of top 10 differentially expressed genes for the current cluster
   vln_plot_rel <- VlnPlot(obj,
          features = rownames(cluster.markers)[1:10],
          ncol = 2,
          pt.size = 0)
  vln_plot_relexp <- paste0("DEG_VlnPlotRelExp_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, vln_plot_relexp), height = 12, width = 6)
  print(vln_plot_rel)
  dev.off()

  return(vln_plot_rel)

}

# Function to create counts violin plots
create_vln_cnt <- function(obj) {

  vln_plot_cnt <- VlnPlot(obj,
          features = rownames(cluster.markers)[1:10],
          slot = "counts", 
          log = TRUE, 
          ncol = 2,
          pt.size = 0)
  vln_plot_counts <- paste0("DEG_VlnPlotCounts_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, vln_plot_counts), height = 12, width = 6)
  print(vln_plot_cnt)
  dev.off()

  return(vln_plot_cnt)

}

# Function to create feature plots
create_feature <- function(obj) {
  
    feature_plot <- FeaturePlot(obj,
            features = rownames(cluster.markers)[1:10], 
            reduction = "umap",
            label = TRUE,
            label.size = 4,
            split.by = "group",
            ncol = 2,
            pt.size = 0)
  feature_plots <- paste0("DEG_FeaturePlot_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, feature_plots), height = 24, width = 6)
  print(feature_plot)
  dev.off()

  return(feature_plot)

}

# Function to create feature plots
create_nebulosa <- function(obj) {
  
    nebulosa_plot <- plot_density(obj,
            features = rownames(cluster.markers)[1:10], 
            reduction = "umap",
            combine = FALSE)
    # Arrange the plots in a single row using patchwork
    nebulosa_plot <- wrap_plots(nebulosa_plot, ncol = 1)
  nebulosa_plots <- paste0("DEG_NebulosaPlot_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, nebulosa_plots), height = 24, width =6)
  print(nebulosa_plot)
  dev.off()

  return(nebulosa_plot)

}

# List to store relative expression violin plots
vln_plot_rel_list <- list()

# List to store counts violin plots
vln_plot_cnt_list <- list()

# List to store feature plots
feature_plot_list <- list()

# List to store nebulosa plots
nebulosa_plot_list <- list()

# Create a list of all cluster identities in obj
cluster.ids <- levels(Idents(obj))

# Initialize a list to store cluster markers
cluster.markers <- list()

# Loop through each Seurat cluster in obj
for (cluster.id in cluster.ids) {
  
  # Find markers for the current cluster
  cluster.markers <- FindMarkers(obj, ident.1 = cluster.id)
  
  # Assign a dynamic object name based on the cluster ID
  object.name <- paste0("cluster.markers.", cluster.id)
  
  # Export cluster markers to a CSV file
  csv_file <- paste0(object.name, ".csv")
  write.csv(cluster.markers, file = file.path(dir_save, paste0(csv_file)), row.names = TRUE)
  
  # Create plots using functions
  vln_plot_rel <- create_vln_rel(obj)
  vln_plot_cnt <- create_vln_cnt(obj)
  feature_plot <- create_feature(obj)
  nebulosa_plot <- create_nebulosa(obj)


  # Assign the plots to a variable with a dynamic name
  assign(paste0("VlnPlotRel_", cluster.id), vln_plot_rel)
  assign(paste0("VlnPlotCnt_", cluster.id), vln_plot_cnt)
  assign(paste0("FeaturePlot_", cluster.id), feature_plot)
  assign(paste0("NebulosaPlot_", cluster.id), nebulosa_plot)

  # Add the plots to the associated list
  vln_plot_rel_list[[cluster.id]] <- vln_plot_rel
  vln_plot_cnt_list[[cluster.id]] <- vln_plot_cnt
  feature_plot_list[[cluster.id]] <- feature_plot
  nebulosa_plot_list[[cluster.id]] <- nebulosa_plot
  
}

# Plot a heatmap to look at the top 10 differentially expressed genes across all clusters
pdf(paste0(dir_save, "DEG_Heatmap_AllClusters_Top10.pdf"), height = 30, width = 20)
obj.markers %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC) -> top10
DoHeatmap(obj, features = top10$gene) + NoLegend()
invisible(dev.off())

# Find all markers distinguishing an interesting cluster from main PBMC clusters
#InterestClustervOthers.markers <- FindMarkers(obj, ident.1 = 4, ident.2 = c(0:3, 5))
```

Plot top 10 differentially expressed genes per cluster as relative expression.

::: panel-tabset
```{r}
#| fig-height: 25.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(vln_plot_rel_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(vln_plot_rel_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Plot top 10 differentially expressed genes per cluster as counts.

::: panel-tabset
```{r}
#| fig-height: 25.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(vln_plot_cnt_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(vln_plot_cnt_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Plot top 10 differentially expressed genes per cluster as feature plots.

::: panel-tabset
```{r}
#| fig-height: 32.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(feature_plot_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(feature_plot_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Plot top 10 differentially expressed genes as cell density

::: panel-tabset
```{r}
#| fig-height: 32.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(nebulosa_plot_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(nebulosa_plot_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Examine top 10 features that distinguish each cluster as a heatmap and print the top 10 markers that distinguish a cluster of interest from all others. In this case, we look at the markers that distinguish cluster 4 from all others.

```{r, echo = FALSE, warning = FALSE}
#| fig-height: 13

DoHeatmap(obj, features = top10$gene) + NoLegend()
#head(InterestClustervOthers.markers, n = 10)
```

Visualize expression of sorting panel markers on clusters.

```{r, message=FALSE}
#| fig-height: 13

# Plot expression of the sorting panel markers 
 vln_plot_rel <- VlnPlot(obj,
        features = c("CD3G", "CD4", "CD8A", "CD69", "CD40LG", "TNFRSF9"),
        ncol = 2,
        pt.size = 0,
        add.noise = FALSE)
vln_plot_relexp <- paste0("DEG_VlnPlotRelExp_SortingPanel.pdf")
pdf(paste0(dir_save, vln_plot_relexp), height = 12, width = 6)
print(vln_plot_rel)
invisible(dev.off())

vln_plot_cnt <- VlnPlot(obj,
        features = c("CD3G", "CD4", "CD8A", "CD69", "CD40LG", "TNFRSF9"),
        slot = "counts", 
        log = TRUE, 
        ncol = 2,
        pt.size = 0,
        add.noise = FALSE)
vln_plot_counts <- paste0("DEG_VlnPlotCounts_SortingPanel.pdf")
pdf(paste0(dir_save, vln_plot_counts), height = 12, width = 6)
print(vln_plot_cnt)
invisible(dev.off())

feature_plot <- FeaturePlot(obj,
          features = c("CD3G", "CD4", "CD8A", "CD69", "CD40LG", "TNFRSF9"), 
          reduction = "umap",
          label = TRUE,
          label.size = 4,
          split.by = "group",
          pt.size = 0)
feature_plots <- paste0("DEG_FeaturePlot_SortingPanel.pdf")
pdf(paste0(dir_save, feature_plots), height = 24, width = 6)
print(feature_plot)
invisible(dev.off())

nebulosa_plot <- plot_density(obj,
            features = c("CD3G", "CD4", "CD8A", "CD69", "CD40LG", "TNFRSF9"), 
            reduction = "umap",
            combine = FALSE)
nebulosa_plot <- wrap_plots(nebulosa_plot, ncol = 1)
nebulosa_plots <- paste0("DEG_NebulosaPlot_SortingPanel.pdf")
pdf(paste0(dir_save, nebulosa_plots), height = 24, width =6)
print(nebulosa_plot)
dev.off()
```

::: panel-tabset
## Relative Expression

```{r, echo = FALSE}
#| fig-height: 13

print(vln_plot_rel)
```

## Counts

```{r, echo = FALSE}
#| fig-height: 13

print(vln_plot_cnt)
```

## Feature Plots

```{r, echo = FALSE}
#| fig-height: 25.5

print(feature_plot)
```

## Density Plots

```{r, echo = FALSE}
#| fig-height: 25.5

print(nebulosa_plot)
```
:::

### Assign cell types - cellDex

```{r, message = FALSE, warning = FALSE, output = FALSE}
#### Human Primary Cell Atlas Data

# Fetch the HumanPrimaryCellAtlasData reference data
hpca_ref <- HumanPrimaryCellAtlasData()

# Assume 'obj' is your Seurat object
# Convert Seurat object to SingleCellExperiment object
sce <- as.SingleCellExperiment(obj)
# Run SingleR for cell type annotation
predictions <- SingleR(test = sce, ref = hpca_ref, labels = hpca_ref$label.main)
# Add the SingleR predictions to the Seurat object metadata
obj <- AddMetaData(obj, metadata = predictions$labels, col.name = "SingleR_labels_HPCA")
# Verify the annotations
head(obj@meta.data$SingleR_labels_HPCA)

# Run SingleR for cell type annotation - fine
predictions <- SingleR(test = sce, ref = hpca_ref, labels = hpca_ref$label.fine)
# Add the SingleR predictions to the Seurat object metadata - fine
obj <- AddMetaData(obj, metadata = predictions$labels, col.name = "SingleR_labels_HPCA_fine")
# Verify the annotations - fine
head(obj@meta.data$SingleR_labels_HPCA_fine)



#### Database Immune Cell Expression Data

dice_ref <- DatabaseImmuneCellExpressionData()

sce <- as.SingleCellExperiment(obj)
predictions <- SingleR(test = sce, ref = dice_ref, labels = dice_ref$label.main)
obj <- AddMetaData(obj, metadata = predictions$labels, col.name = "SingleR_labels_DICE")
head(obj@meta.data$SingleR_labels_DICE)

predictions <- SingleR(test = sce, ref = dice_ref, labels = dice_ref$label.fine)
obj <- AddMetaData(obj, metadata = predictions$labels, col.name = "SingleR_labels_DICE_fine")
head(obj@meta.data$SingleR_labels_DICE_fine)

#### Monaco Immune Data

monaco_ref <- MonacoImmuneData()

sce <- as.SingleCellExperiment(obj)
predictions <- SingleR(test = sce, ref = monaco_ref, labels = monaco_ref$label.main)
obj <- AddMetaData(obj, metadata = predictions$labels, col.name = "SingleR_labels_MID")
head(obj@meta.data$SingleR_labels_MID)

predictions <- SingleR(test = sce, ref = monaco_ref, labels = monaco_ref$label.fine)
obj <- AddMetaData(obj, metadata = predictions$labels, col.name = "SingleR_labels_MID_fine")
head(obj@meta.data$SingleR_labels_MID_fine)

```

### Assign cell types - scType

Predict cell types based on expression using sc-Type

```{r, warning = FALSE}
# Load gene set preparation function 
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")

# Load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")
```

Prepare gene sets from input cell marker file. This uses the default of in-built cell marker DB.

```{r, warning = FALSE}
# DB file
#db_ <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";

db_ <- "data/ScTypeDB_full_MLRPedit.xlsx"
tissue <- "Immune system" # e.g. Immune system, Pancreas, Liver, Eye, Kidney, Brain, Lung, Adrenal, Heart, Intestine, Muscle, Placenta, Spleen, Stomach, Thymus 

# prepare gene sets
gs_list <- gene_sets_prepare(db_, tissue)
```

Run sc-Type.

```{r, message = FALSE}

### CHANGE Idents(obj) to obj@meta.data$seurat_clusters

# check Seurat object version (scRNA-seq matrix extracted differently in Seurat v4/v5)
seurat_package_v5 <- isFALSE('counts' %in% names(attributes(obj[["RNA"]])));
print(sprintf("Seurat object %s is used", ifelse(seurat_package_v5, "v5", "v4")))

# extract scaled scRNA-seq matrix
scRNAseqData_scaled <- if (seurat_package_v5) as.matrix(obj[["RNA"]]$scale.data) else as.matrix(obj[["RNA"]]@scale.data)

# run ScType
es.max <- sctype_score(scRNAseqData = scRNAseqData_scaled, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# merge by cluster
cL_resutls <- do.call("rbind", lapply(unique(Idents(obj)), function(cl){
  es.max.cl = sort(rowSums(es.max[ ,rownames(obj@meta.data[Idents(obj)==cl, ])]), decreasing = !0)
  head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(Idents(obj)==cl)), 10)
}))
sctype_scores <- cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] <- "Unknown"
print(sctype_scores)
```

Overlay cell type IDs on UMAP.

```{r}
### CHANGE Idents(obj) to obj@meta.data$seurat_clusters

obj@meta.data$sctype_classification = NA
for(j in unique(sctype_scores$cluster)){
  cl_type = sctype_scores[sctype_scores$cluster==j,]; 
  obj@meta.data$sctype_classification[Idents(obj) == j] = as.character(cl_type$type[1])
}

pdf(paste0(dir_save, "umap_annotated.pdf"), height = 7, width = 10)
umap_annotated <- DimPlot(obj, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'sctype_classification')
print(umap_annotated)
invisible(dev.off())
umap_annotated
```

```{r}
#| fig-height: 6.5

pdf(paste0(dir_save, "umap_annotated_splitgroup.pdf"), height = 7, width = 15)
umap_annotated_group <- DimPlot(obj, reduction = "umap", split.by = "group", group.by = 'sctype_classification')
print(umap_annotated_group)
invisible(dev.off())
umap_annotated_group
```

### Save Seurat object with cell types assigned as Rdata and rds

```{r}
save(obj, file = paste0(dir_save, "Seurat_ClusterIDCells_obj_AssignedCellTypeIntermediate.Rdata"))
saveRDS(obj, file = paste0(dir_save, "Seurat_ClusterIDcells_obj_AssignedCellTypeIntermediate.rds"))
```

### Plot feature based scType clusters

```{r, message=FALSE, warning = FALSE}
plot1 <- DimPlot(obj, reduction = "umap", group.by = c("sctype_classification"), split.by = "group") +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 5, override.aes = list(size = 5)))
plot2 <- DimPlot(obj, reduction = "umap", group.by = c("RUN"), split.by = "group") +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 5, override.aes = list(size = 5)))
plot3 <- DimPlot(obj, reduction = "umap", group.by = c("PID"), split.by = "group") +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 7, override.aes = list(size = 5)))
plot4 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT"), split.by = "group") +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 2, override.aes = list(size = 5)))
plot5 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_group")) +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 4, override.aes = list(size = 5)))
plot6 <- DimPlot(obj, reduction = "umap", group.by = c("STIM")) +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 4, override.aes = list(size = 5)))
plot7 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_STIM")) +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 4, override.aes = list(size = 5)))
plot8 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_STIM_group")) +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 4, override.aes = list(size = 5)))
plot9 <- DimPlot(obj, reduction = "umap", group.by = c("sctype_classification")) +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 5, override.aes = list(size = 5)))

pdf(paste0(dir_save, "umap_sctype_group_res.clustree.pdf"), height = 7.5, width = 11)
print(plot1)
invisible(dev.off())

pdf(paste0(dir_save, "umap_sctype_RUN_res.clustree.pdf"), height = 5, width = 10)
print(plot2)
invisible(dev.off())

pdf(paste0(dir_save, "umap_sctype_PID_res.clustree.pdf"), height = 5, width = 10)
print(plot3)
invisible(dev.off())

pdf(paste0(dir_save, "umap_sctype_VISIT_res.clustree.pdf"), height = 5, width = 10)
print(plot4)
invisible(dev.off())

pdf(paste0(dir_save, "umap_sctype_VISITgroup_res.clustree.pdf"), height = 5, width = 10)
print(plot5)
invisible(dev.off())

pdf(paste0(dir_save, "umap_sctype_STIM_res.clustree.pdf"), height = 5, width = 10)
print(plot6)
invisible(dev.off())

pdf(paste0(dir_save, "umap_sctype_VISITSTIM_res.clustree.pdf"), height = 5, width = 10)
print(plot7)
invisible(dev.off())

pdf(paste0(dir_save, "umap_sctype_VISITSTIMgroup_res.clustree.pdf"), height = 5, width = 10)
print(plot8)
invisible(dev.off())

pdf(paste0(dir_save, "umap_sctype_refinedclusters_res.clustree.pdf"), height = 7.5, width = 11)
print(plot9)
invisible(dev.off())
```

::: panel-tabset
## UMAP group

```{r, echo = FALSE}
print(plot1)
```

## UMAP RUN

```{r, echo = FALSE}
#| fig-height: 10
print(plot2 / plot9)
```

## UMAP PID

```{r, echo = FALSE}
#| fig-height: 10
print(plot3 / plot9)
```

## UMAP VISIT

```{r, echo = FALSE}
#| fig-height: 10
print(plot4 / plot9)
```

## UMAP VISIT & group

```{r, echo = FALSE}
#| fig-height: 10
print(plot5 / plot9)
```

## UMAP STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot6 / plot9)
```

## UMAP VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot7 / plot9)
```

## UMAP VISIT & STIM & group

```{r, echo = FALSE}
#| fig-height: 10
print(plot8 / plot9)
```
:::

### Inspect cluster proportions on sctype clusters

Now that cell type assignment is complete, we will re-examine the proportion of each cluster that is comprised of cells with key metadata features: RUN, group, PID, and VISIT. Proportions are shown alongside total cell number per cluster.

```{r, warning = FALSE, message = FALSE}

plot_sctype_clusters = function (srat, batchcolumn) {
  ## take an integrated Seurat object, plot distributions over sctype_classification

  # Ensure the sctype_classification column is treated as a factor and handle NA values
  srat@meta.data$sctype_classification <- as.factor(srat@meta.data$sctype_classification)
  srat@meta.data <- srat@meta.data[!is.na(srat@meta.data$sctype_classification), ]

  # Ensure the batchcolumn is treated as a factor
  srat@meta.data[[batchcolumn]] <- as.factor(srat@meta.data[[batchcolumn]])

  # Check lengths of the columns
  if (length(srat@meta.data$sctype_classification) != length(srat@meta.data[[batchcolumn]])) {
    stop("The lengths of feature_based_ID and the batch column do not match.")
  }

  count_table <- table(srat@meta.data$sctype_classification, srat@meta.data[[batchcolumn]])
  count_mtx   <- as.data.frame.matrix(count_table)
  count_mtx$cluster <- rownames(count_mtx)
  melt_mtx    <- melt(count_mtx)
  melt_mtx$cluster <- as.factor(melt_mtx$cluster)

  # Calculate the total number of cells per cluster and sort by size in descending order
  cluster_size   <- aggregate(value ~ cluster, data = melt_mtx, FUN = sum)
  sorted_labels <- cluster_size$cluster[order(cluster_size$value, decreasing = F)]
  cluster_size$cluster <- factor(cluster_size$cluster, levels = sorted_labels)
  melt_mtx$cluster <- factor(melt_mtx$cluster, levels = sorted_labels)

  colnames(melt_mtx)[2] <- "dataset"

  p1 <- ggplot(cluster_size, aes(y = cluster, x = value)) + 
    geom_bar(position = "dodge", stat = "identity", fill = "grey60") +
    geom_text(aes(label = value), hjust = 1.5, size = 3) +
    theme_bw() + scale_x_log10() + 
    xlab("Cells per cluster, log10 scale") + ylab("")
  p2 <- ggplot(melt_mtx, aes(x = cluster, y = value, fill = dataset)) +
    geom_bar(position = "fill", stat = "identity") + theme_bw() + coord_flip() +
    ylab("Fraction of cells in each dataset") + xlab("Cluster") + theme(legend.position = "bottom") +
    guides(color = guide_legend(ncol = 3, override.aes = list(size = 5)))

  p2 / p1 + plot_layout(widths = c(3,3))
}

plot1 <- plot_sctype_clusters(obj, 'group')
plot2 <- plot_sctype_clusters(obj, 'RUN')
plot3 <- plot_sctype_clusters(obj, 'PID')
plot4 <- plot_sctype_clusters(obj, 'VISIT')
plot5 <- plot_sctype_clusters(obj, 'VISIT_group')
plot6 <- plot_sctype_clusters(obj, 'STIM')
plot7 <- plot_sctype_clusters(obj, 'VISIT_STIM')
plot8 <- plot_sctype_clusters(obj, 'VISIT_STIM_group')

pdf(paste0(dir_save, "prop_sctype_group_res.clustree.pdf"), height = 5, width = 10)
print(plot1)
invisible(dev.off())

pdf(paste0(dir_save, "prop_sctype_RUN_res.clustree.pdf"), height = 5, width = 10)
print(plot2)
invisible(dev.off())

pdf(paste0(dir_save, "prop_sctype_PID_res.clustree.pdf"), height = 5, width = 10)
print(plot3)
invisible(dev.off())

pdf(paste0(dir_save, "prop_sctype_VISIT_res.clustree.pdf"), height = 5, width = 10)
print(plot4)
invisible(dev.off())

pdf(paste0(dir_save, "prop_sctype_VISITgroup_res.clustree.pdf"), height = 5, width = 10)
print(plot5)
invisible(dev.off())

pdf(paste0(dir_save, "prop_sctype_STIM_res.clustree.pdf"), height = 5, width = 10)
print(plot6)
invisible(dev.off())

pdf(paste0(dir_save, "prop_sctype_VISITSTIM_res.clustree.pdf"), height = 5, width = 10)
print(plot7)
invisible(dev.off())

pdf(paste0(dir_save, "prop_sctype_VISITSTIMgroup_res.clustree.pdf"), height = 5, width = 10)
print(plot8)
invisible(dev.off())
```

::: panel-tabset
## Proportions group

```{r, echo = FALSE}
#| fig-height: 5
print(plot1)
```

## Proportions RUN

```{r, echo = FALSE}
#| fig-height: 5
print(plot2)
```

## Proportions PID

```{r, echo = FALSE}
#| fig-height: 5
print(plot3)
```

## Proportions VISIT

```{r, echo = FALSE}
#| fig-height: 5
print(plot4)
```

## Proportions VISIT & group

```{r, echo = FALSE}
#| fig-height: 5
print(plot5)
```

## Proportions STIM

```{r, echo = FALSE}
#| fig-height: 5
print(plot6)
```

## Proportions VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 5
print(plot7)
```

## Proportions VISIT & STIM & group

```{r, echo = FALSE}
#| fig-height: 5
print(plot8)
```
:::

### Assign cluster IDs based on features

```{r}
# Extract top markers for each cluster
top_markers <- obj.markers %>%
  group_by(cluster) %>%
  #order_by(p_val_adj) %>% 
  #slice(1:10) %>% 
  slice_min(order_by = p_val_adj, n = 10) %>% # Select the top markers by adjusted p-value
  summarize(
    top_cluster_markers = paste(gene, collapse = "_"), # Concatenate top marker names
    #.groups = "drop" # Drop grouping for a clean dataframe
  )

# Identify unique genes for each cluster
# Split the concatenated `top_cluster_markers` into individual genes for all clusters
all_genes <- top_markers %>%
  mutate(
    genes_list = strsplit(top_cluster_markers, "_") # Create list of individual genes
  ) %>%
  unnest(genes_list) # Expand list into rows

# Count occurrences of each gene across all clusters
gene_counts <- all_genes %>%
  count(genes_list, name = "gene_occurrence")

# Filter to retain only unique genes (appearing in one cluster's `feature_based_ID`)
unique_genes <- gene_counts %>%
  filter(gene_occurrence == 1) %>%
  pull(genes_list) # Extract list of unique genes

# Assign unique genes to each cluster
# Filter `all_genes` to keep only unique genes
unique_markers <- all_genes %>%
  filter(genes_list %in% unique_genes) %>%
  group_by(cluster) %>%
  summarize(
    feature_based_ID = paste(genes_list, collapse = "_"), # Concatenate unique genes
    .groups = "drop"
  )

# Merge unique markers back to `top_markers`
top_markers <- top_markers %>%
  left_join(unique_markers, by = "cluster")

# Add top markers and feature-based IDs to the Seurat metadata
obj@meta.data$top_cluster_markers <- top_markers$top_cluster_markers[match(Idents(obj), top_markers$cluster)]
obj@meta.data$feature_based_ID <- top_markers$feature_based_ID[match(Idents(obj), top_markers$cluster)]

# Assign feature_based_ID as the new identities
Idents(obj) <- obj@meta.data$feature_based_ID

# Create a mapping of each feature_based_ID to a letter based on the number of cells
feature_based_ID_counts <- table(Idents(obj))
sorted_feature_based_IDs <- names(sort(feature_based_ID_counts, decreasing = TRUE))
label_mapping <- setNames(LETTERS[1:length(sorted_feature_based_IDs)], sorted_feature_based_IDs)

# Add a new column with the letter mapping
obj@meta.data$feature_based_ID_letter <- label_mapping[as.character(Idents(obj))]

# Verify the change
head(Idents(obj))
head(obj@meta.data$feature_based_ID_letter)

```

### Plot feature based refined clusters

```{r, message=FALSE, warning = FALSE}
plot1 <- DimPlot(obj, reduction = "umap", group.by = c("feature_based_ID"), split.by = "group") +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 1, override.aes = list(size = 5)))
plot2 <- DimPlot(obj, reduction = "umap", group.by = c("RUN"), split.by = "group") +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 5, override.aes = list(size = 5)))
plot3 <- DimPlot(obj, reduction = "umap", group.by = c("PID"), split.by = "group") +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 7, override.aes = list(size = 5)))
plot4 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT"), split.by = "group") +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 2, override.aes = list(size = 5)))
plot5 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_group")) +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 4, override.aes = list(size = 5)))
plot6 <- DimPlot(obj, reduction = "umap", group.by = c("STIM")) +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 4, override.aes = list(size = 5)))
plot7 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_STIM")) +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 4, override.aes = list(size = 5)))
plot8 <- DimPlot(obj, reduction = "umap", group.by = c("VISIT_STIM_group")) +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 4, override.aes = list(size = 5)))
plot9 <- DimPlot(obj, reduction = "umap", group.by = c("sctype_classification")) +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 4, override.aes = list(size = 5)))
plot10 <- DimPlot(obj, reduction = "umap", group.by = c("feature_based_ID")) +
  theme(legend.position = "bottom", legend.text = element_text(size = 7)) +
  guides(color = guide_legend(ncol = 1, override.aes = list(size = 5)))

pdf(paste0(dir_save, "umap_FBID_group_res.clustree.pdf"), height = 7.5, width = 11)
print(plot1)
invisible(dev.off())

pdf(paste0(dir_save, "umap_FBID_RUN_res.clustree.pdf"), height = 5, width = 10)
print(plot2)
invisible(dev.off())

pdf(paste0(dir_save, "umap_FBID_PID_res.clustree.pdf"), height = 5, width = 10)
print(plot3)
invisible(dev.off())

pdf(paste0(dir_save, "umap_FBID_VISIT_res.clustree.pdf"), height = 5, width = 10)
print(plot4)
invisible(dev.off())

pdf(paste0(dir_save, "umap_FBID_VISITgroup_res.clustree.pdf"), height = 5, width = 10)
print(plot5)
invisible(dev.off())

pdf(paste0(dir_save, "umap_FBID_STIM_res.clustree.pdf"), height = 5, width = 10)
print(plot6)
invisible(dev.off())

pdf(paste0(dir_save, "umap_FBID_VISITSTIM_res.clustree.pdf"), height = 5, width = 10)
print(plot7)
invisible(dev.off())

pdf(paste0(dir_save, "umap_FBID_VISITSTIMgroup_res.clustree.pdf"), height = 5, width = 10)
print(plot8)
invisible(dev.off())

pdf(paste0(dir_save, "umap_FBID_sctype_res.clustree.pdf"), height = 5, width = 10)
print(plot9)
invisible(dev.off())

pdf(paste0(dir_save, "umap_FBID_refinedclusters_res.clustree.pdf"), height = 7.5, width = 11)
print(plot10)
invisible(dev.off())
```

::: panel-tabset
## UMAP group

```{r, echo = FALSE}
#| fig-height: 10
print(plot1)
```

## UMAP RUN

```{r, echo = FALSE}
#| fig-height: 20
print(plot2 / plot10)
```

## UMAP PID

```{r, echo = FALSE}
#| fig-height: 20
print(plot3 / plot10)
```

## UMAP VISIT

```{r, echo = FALSE}
#| fig-height: 20
print(plot4 / plot10)
```

## UMAP VISIT & group

```{r, echo = FALSE}
#| fig-height: 20
print(plot5 / plot10)
```

## UMAP STIM

```{r, echo = FALSE}
#| fig-height: 20
print(plot6 / plot10)
```

## UMAP VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 20
print(plot7 / plot10)
```

## UMAP VISIT & STIM & group

```{r, echo = FALSE}
#| fig-height: 20
print(plot8 / plot10)
```

## UMAP scType classification

```{r, echo = FALSE}
#| fig-height: 30
print(plot9 / plot10)
```
:::

### Inspect cluster proportions on refined clusters

Now that cluster refinement is complete, we will re-examine the proportion of each cluster that is comprised of cells with key metadata features: RUN, group, PID, and VISIT. Proportions are shown alongside total cell number per cluster. Compare these outputs to those above for integrated clusters to determine how cluster composition was changed by refining cluster resolution.

```{r, warning = FALSE, message = FALSE}

plot_FBID_clusters = function (srat, batchcolumn) {
  ## take an integrated Seurat object, plot distributions over feature_based_ID

  # Ensure the feature_based_ID column is treated as a factor and handle NA values
  srat@meta.data$feature_based_ID_letter <- as.factor(srat@meta.data$feature_based_ID_letter)
  srat@meta.data <- srat@meta.data[!is.na(srat@meta.data$feature_based_ID_letter), ]

  # Ensure the batchcolumn is treated as a factor
  srat@meta.data[[batchcolumn]] <- as.factor(srat@meta.data[[batchcolumn]])

  # Check lengths of the columns
  if (length(srat@meta.data$feature_based_ID_letter) != length(srat@meta.data[[batchcolumn]])) {
    stop("The lengths of feature_based_ID_letter and the batch column do not match.")
  }

  count_table <- table(srat@meta.data$feature_based_ID_letter, srat@meta.data[[batchcolumn]])
  count_mtx   <- as.data.frame.matrix(count_table)
  count_mtx$cluster <- rownames(count_mtx)
  melt_mtx    <- melt(count_mtx)
  melt_mtx$cluster <- as.factor(melt_mtx$cluster)

  # Calculate the total number of cells per cluster and sort by size in descending order
  cluster_size   <- aggregate(value ~ cluster, data = melt_mtx, FUN = sum)
  sorted_labels <- cluster_size$cluster[order(cluster_size$value, decreasing = F)]
  cluster_size$cluster <- factor(cluster_size$cluster, levels = sorted_labels)
  melt_mtx$cluster <- factor(melt_mtx$cluster, levels = sorted_labels)

  colnames(melt_mtx)[2] <- "dataset"

  p1 <- ggplot(cluster_size, aes(y = cluster, x = value)) + 
    geom_bar(position = "dodge", stat = "identity", fill = "grey60") +
    geom_text(aes(label = value), hjust = 1.5, size = 3) +
    theme_bw() + scale_x_log10() + 
    xlab("Cells per cluster, log10 scale") + ylab("")
  p2 <- ggplot(melt_mtx, aes(x = cluster, y = value, fill = dataset)) +
    geom_bar(position = "fill", stat = "identity") + theme_bw() + coord_flip() +
    ylab("Fraction of cells in each dataset") + xlab("Cluster") + theme(legend.position = "left")

  # Create a legend as a text grob using the existing feature_based_ID_letter column
  legend_text <- paste(label_mapping, names(label_mapping), sep = ": ", collapse = "\n")
  legend_grob <- textGrob(legend_text, x = unit(0, "npc"), y = unit(1, "npc"), just = c("left", "top"), gp = gpar(fontsize = 7))

  # Combine the plots in a grid format with 3:2 width ratio for p2 and p1
  combined_plot <- (p2 + p1 + plot_layout(widths = c(3, 2))) / wrap_elements(legend_grob) + plot_layout(heights = c(2, 1))

  combined_plot
}

plot1 <- plot_FBID_clusters(obj, 'group')
plot2 <- plot_FBID_clusters(obj, 'RUN')
plot3 <- plot_FBID_clusters(obj, 'PID')
plot4 <- plot_FBID_clusters(obj, 'VISIT')
plot5 <- plot_FBID_clusters(obj, 'VISIT_group')
plot6 <- plot_FBID_clusters(obj, 'STIM')
plot7 <- plot_FBID_clusters(obj, 'VISIT_STIM')
plot8 <- plot_FBID_clusters(obj, 'VISIT_STIM_group')
plot9 <- plot_FBID_clusters(obj, 'sctype_classification')
plot10 <- plot_sctype_clusters(obj, 'feature_based_ID_letter')

pdf(paste0(dir_save, "prop_FBID_group_res.clustree.pdf"), height = 5, width = 10)
print(plot1)
invisible(dev.off())

pdf(paste0(dir_save, "prop_FBID_RUN_res.clustree.pdf"), height = 5, width = 10)
print(plot2)
invisible(dev.off())

pdf(paste0(dir_save, "prop_FBID_PID_res.clustree.pdf"), height = 5, width = 10)
print(plot3)
invisible(dev.off())

pdf(paste0(dir_save, "prop_FBID_VISIT_res.clustree.pdf"), height = 5, width = 10)
print(plot4)
invisible(dev.off())

pdf(paste0(dir_save, "prop_FBID_VISITgroup_res.clustree.pdf"), height = 5, width = 10)
print(plot5)
invisible(dev.off())

pdf(paste0(dir_save, "prop_FBID_STIM_res.clustree.pdf"), height = 5, width = 10)
print(plot6)
invisible(dev.off())

pdf(paste0(dir_save, "prop_FBID_VISITSTIM_res.clustree.pdf"), height = 5, width = 10)
print(plot7)
invisible(dev.off())

pdf(paste0(dir_save, "prop_FBID_VISITSTIMgroup_res.clustree.pdf"), height = 5, width = 10)
print(plot8)
invisible(dev.off())

pdf(paste0(dir_save, "prop_FBID_sctype_res.clustree.pdf"), height = 5, width = 10)
print(plot9)
invisible(dev.off())

pdf(paste0(dir_save, "prop_FBID_sctypeREVERSE_res.clustree.pdf"), height = 5, width = 10)
print(plot10)
invisible(dev.off())
```

::: panel-tabset
## Proportions group

```{r, echo = FALSE}
#| fig-height: 12
print(plot1)
```

## Proportions RUN

```{r, echo = FALSE}
#| fig-height: 12
print(plot2)
```

## Proportions PID

```{r, echo = FALSE}
#| fig-height: 12
print(plot3)
```

## Proportions VISIT

```{r, echo = FALSE}
#| fig-height: 5
print(plot4)
```

## Proportions VISIT & group

```{r, echo = FALSE}
#| fig-height: 5
print(plot5)
```

## Proportions STIM

```{r, echo = FALSE}
#| fig-height: 5
print(plot6)
```

## Proportions VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 5
print(plot7)
```

## Proportions VISIT & STIM & group

```{r, echo = FALSE}
#| fig-height: 5
print(plot8)
```

## Proportions scType

```{r, echo = FALSE}
#| fig-height: 10
print(plot9)
```

## Proportions scType REVERSE

```{r, echo = FALSE}
#| fig-height: 10
print(plot10)
```
:::

### Summarize cluster data for the M72 Immune Correlates Consortium data upload

```{r, eval = FALSE}
# MAKE COLUMN sample for PID VISIT
# Create the summary dataframes for consoritum data upload
consortium_data <- obj@meta.data %>%
  group_by(sample, PID, VISIT, STIM, group, feature_based_ID_letter, feature_based_ID) %>%
  summarize(
    cell_count = n(),  
    .groups = "drop"   
  ) %>%
  ungroup() %>%
  mutate(
    nCluster = ave(cell_count, feature_based_ID_letter, FUN = sum),
    nSample = ave(cell_count, sample, FUN = sum), 
    nVisit = ave(cell_count, VISIT, FUN = sum),
    nStim = ave(cell_count, STIM, FUN = sum),
    nGroup = ave(cell_count, group, FUN = sum), 
    totalCells = sum(cell_count)  
  )
# Calculate the proportion of cells for each VISIT within each cluster
prop_visit_data <- consortium_data %>%
  group_by(feature_based_ID_letter, VISIT) %>%
  summarize(
    visit_cell_count = sum(cell_count),  # Sum of cell_count for each VISIT within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propVISITperCLUSTER = visit_cell_count / nCluster  # Proportion of cells for each VISIT within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, VISIT, propVISITperCLUSTER)

# Merge the proportion data for VISIT back into the consortium_data dataframe
consortium_data <- consortium_data %>%
  left_join(prop_visit_data, by = c("feature_based_ID_letter", "VISIT"))

# Calculate the proportion of cells for each STIM within each cluster
prop_stim_data <- consortium_data %>%
  group_by(feature_based_ID_letter, STIM) %>%
  summarize(
    stim_cell_count = sum(cell_count),  # Sum of cell_count for each STIM within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propSTIMperCLUSTER = stim_cell_count / nCluster  # Proportion of cells for each STIM within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, STIM, propSTIMperCLUSTER)

# Merge the proportion data for STIM back into the consortium_data dataframe
consortium_data <- consortium_data %>%
  left_join(prop_stim_data, by = c("feature_based_ID_letter", "STIM"))

# Calculate the proportion of cells for each group within each cluster
prop_group_data <- consortium_data %>%
  group_by(feature_based_ID_letter, group) %>%
  summarize(
    group_cell_count = sum(cell_count),  # Sum of cell_count for each group within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propGROUPperCLUSTER = group_cell_count / nCluster  # Proportion of cells for each group within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, group, propGROUPperCLUSTER)

# Merge the proportion data for group back into the consortium_data dataframe
consortium_data <- consortium_data %>%
  left_join(prop_group_data, by = c("feature_based_ID_letter", "group"))

# Calculate the proportion of cells for each combination of VISIT, STIM, and group within each cluster
prop_visit_stim_group_data <- consortium_data %>%
  group_by(feature_based_ID_letter, VISIT, STIM, group) %>%
  summarize(
    visit_stim_group_cell_count = sum(cell_count),  # Sum of cell_count for each combination of VISIT, STIM, and group within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propVISITSTIMGROUPperCLUSTER = visit_stim_group_cell_count / nCluster  # Proportion of cells for each combination of VISIT, STIM, and group within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, VISIT, STIM, group, propVISITSTIMGROUPperCLUSTER)

# Merge the proportion data for VISIT, STIM, and group back into the consortium_data dataframe
consortium_data <- consortium_data %>%
  left_join(prop_visit_stim_group_data, by = c("feature_based_ID_letter", "VISIT", "STIM", "group"))

# Calculate the proportion of cells for each combination of VISIT, STIM, and group within each cluster for each PID
prop_visit_stim_group_pid_data <- consortium_data %>%
  group_by(feature_based_ID_letter, VISIT, STIM, group, PID) %>%
  summarize(
    visit_stim_group_pid_cell_count = sum(cell_count),  # Sum of cell_count for each combination of VISIT, STIM, and group within each cluster for each PID
    .groups = "drop"
  ) %>%
  left_join(consortium_data %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propVISITSTIMGROUPperCLUSTERperPID = visit_stim_group_pid_cell_count / nCluster  # Proportion of cells for each combination of VISIT, STIM, and group within each cluster for each PID
  ) %>%
  dplyr::select(feature_based_ID_letter, VISIT, STIM, group, propVISITSTIMGROUPperCLUSTERperPID)

# Merge the proportion data for VISIT, STIM, and group per PID back into the consortium_data dataframe
consortium_data <- consortium_data %>%
  left_join(prop_visit_stim_group_pid_data, by = c("feature_based_ID_letter", "VISIT", "STIM", "group", "PID"))

# Save consortium_data_split_celltype as a .csv file
write.csv(consortium_data, paste0(dir_save, "consortium_data.csv"), row.names = FALSE)





# Create the summary dataframe consortium_data_visit_placebo
consortium_data_split_celltype <- obj@meta.data %>%
  group_by(sample, PID, VISIT, group, feature_based_ID_letter, feature_based_ID, sctype_classification, SingleR_labels_HPCA) %>%
  summarize(
    cell_count = n(),  # Count the number of cells in each group
    .groups = "drop"   # Drop grouping for a clean dataframe
  ) %>%
  ungroup() %>%
  mutate(
    nCluster = ave(cell_count, feature_based_ID_letter, FUN = sum),
    nCelltype = ave(cell_count, sctype_classification, FUN = sum),  # Sum of cell_count for the same sctype_classification
    nParent = ave(cell_count, SingleR_labels_HPCA, FUN = sum),  # Sum of cell_count for the same SingleR_labels_HPCA
    nSample = ave(cell_count, sample, FUN = sum),  # Sum of cell_count for the same sample
    nVisit = ave(cell_count, VISIT, FUN = sum),
    nGroup = ave(cell_count, group, FUN = sum),  # Sum of cell_count for the same group
    totalCells = sum(cell_count)  # Total number of cells in the dataset
  )

# Calculate the proportion of cells for each VISIT within each cluster
prop_visit_data <- consortium_data_split_celltype %>%
  group_by(feature_based_ID_letter, VISIT) %>%
  summarize(
    visit_cell_count = sum(cell_count),  # Sum of cell_count for each VISIT within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data_split_celltype %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propVISITperCLUSTER = visit_cell_count / nCluster  # Proportion of cells for each VISIT within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, VISIT, propVISITperCLUSTER)

# Merge the proportion data for VISIT back into the consortium_data_split_celltype dataframe
consortium_data_split_celltype <- consortium_data_split_celltype %>%
  left_join(prop_visit_data, by = c("feature_based_ID_letter", "VISIT"))

# Calculate the proportion of cells for each STIM within each cluster
prop_stim_data <- consortium_data_split_celltype %>%
  group_by(feature_based_ID_letter, STIM) %>%
  summarize(
    stim_cell_count = sum(cell_count),  # Sum of cell_count for each STIM within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data_split_celltype %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propSTIMperCLUSTER = stim_cell_count / nCluster  # Proportion of cells for each STIM within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, STIM, propSTIMperCLUSTER)

# Merge the proportion data for STIM back into the consortium_data_split_celltype dataframe
consortium_data_split_celltype <- consortium_data_split_celltype %>%
  left_join(prop_stim_data, by = c("feature_based_ID_letter", "STIM"))

# Calculate the proportion of cells for each group within each cluster
prop_group_data <- consortium_data_split_celltype %>%
  group_by(feature_based_ID_letter, group) %>%
  summarize(
    group_cell_count = sum(cell_count),  # Sum of cell_count for each group within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data_split_celltype %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propGROUPperCLUSTER = group_cell_count / nCluster  # Proportion of cells for each group within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, group, propGROUPperCLUSTER)

# Merge the proportion data for group back into the consortium_data_split_celltype dataframe
consortium_data_split_celltype <- consortium_data_split_celltype %>%
  left_join(prop_group_data, by = c("feature_based_ID_letter", "group"))

# Calculate the proportion of cells for each combination of VISIT, STIM, and group within each cluster
prop_visit_stim_group_data <- consortium_data_split_celltype %>%
  group_by(feature_based_ID_letter, VISIT, STIM, group) %>%
  summarize(
    visit_stim_group_cell_count = sum(cell_count),  # Sum of cell_count for each combination of VISIT, and STIM, and group within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data_split_celltype %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propVISITSTIMGROUPperCLUSTER = visit_stim_group_cell_count / nCluster  # Proportion of cells for each combination of VISIT, STIM, and group within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, VISIT, STIM, group, propVISITSTIMGROUPperCLUSTER)

# Merge the proportion data for VISIT, STIM, and group back into the consortium_data_split_celltype dataframe
consortium_data_split_celltype <- consortium_data_split_celltype %>%
  left_join(prop_visit_stim_group_data, by = c("feature_based_ID_letter", "VISIT", "STIM" "group"))

# Calculate the proportion of cells for each combination of VISIT, STIM, and group within each cluster per PID
prop_visit_stim_group_pid_data <- consortium_data_split_celltype %>%
  group_by(feature_based_ID_letter, VISIT, STIM, group, PID) %>%
  summarize(
    visit_stim_group_pid_cell_count = sum(cell_count),  # Sum of cell_count for each combination of VISIT, STIM, and group within each cluster per PID
    .groups = "drop"
  ) %>%
  left_join(consortium_data_split_celltype %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propVISITSTIMGROUPperCLUSTERperPID = visit_stim_group_pid_cell_count / nCluster  # Proportion of cells for each combination of VISIT, STIM, and group within each cluster per PID
  ) %>%
  dplyr::select(feature_based_ID_letter, VISIT, STIM, group, propVISITSTIMGROUPperCLUSTERperPID)

# Merge the proportion data for VISIT, STIM, and group per PID back into the consortium_data_split_celltype dataframe
consortium_data_split_celltype <- consortium_data_split_celltype %>%
  left_join(prop_visit_stim_group_pid_data, by = c("feature_based_ID_letter", "VISIT", "STIM", "group", "PID"))

# Save consortium_data_split_celltype as a .csv file
write.csv(consortium_data_split_celltype, paste0(dir_save, "consortium_data_split_celltype.csv"), row.names = FALSE)






consortium_data_visit_group <- obj@meta.data %>%
  group_by(VISIT, group, feature_based_ID_letter, feature_based_ID) %>%
  summarize(
    cell_count = n(),  
    .groups = "drop"   
  ) %>%
  ungroup() %>%
  mutate(
    nCluster = ave(cell_count, feature_based_ID_letter, FUN = sum),
    nVisit = ave(cell_count, VISIT, FUN = sum),
    nGroup = ave(cell_count, group, FUN = sum), 
    totalCells = sum(cell_count)  
  )
# Calculate the proportion of cells for each VISIT within each cluster
prop_visit_data <- consortium_data_visit_group %>%
  group_by(feature_based_ID_letter, VISIT) %>%
  summarize(
    visit_cell_count = sum(cell_count),  # Sum of cell_count for each VISIT within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data_visit_group %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propVISITperCLUSTER = visit_cell_count / nCluster  # Proportion of cells for each VISIT within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, VISIT, propVISITperCLUSTER)

# Merge the proportion data for VISIT back into the consortium_data_visit_group dataframe
consortium_data_visit_group <- consortium_data_visit_group %>%
  left_join(prop_visit_data, by = c("feature_based_ID_letter", "VISIT"))

# Calculate the proportion of cells for each STIM within each cluster
prop_stim_data <- consortium_data_visit_group %>%
  group_by(feature_based_ID_letter, STIM) %>%
  summarize(
    stim_cell_count = sum(cell_count),  # Sum of cell_count for each STIM within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data_visit_group %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propSTIMperCLUSTER = stim_cell_count / nCluster  # Proportion of cells for each STIM within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, STIM, propSTIMperCLUSTER)

# Merge the proportion data for STIM back into the consortium_data_visit_group dataframe
consortium_data_visit_group <- consortium_data_visit_group %>%
  left_join(prop_stim_data, by = c("feature_based_ID_letter", "STIM"))

# Calculate the proportion of cells for each group within each cluster
prop_group_data <- consortium_data_visit_group %>%
  group_by(feature_based_ID_letter, group) %>%
  summarize(
    group_cell_count = sum(cell_count),  # Sum of cell_count for each group within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data_visit_group %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propGROUPperCLUSTER = group_cell_count / nCluster  # Proportion of cells for each group within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, group, propGROUPperCLUSTER)

# Merge the proportion data for group back into the consortium_data_visit_group dataframe
consortium_data_visit_group <- consortium_data_visit_group %>%
  left_join(prop_group_data, by = c("feature_based_ID_letter", "group"))

# Calculate the proportion of cells for each combination of VISIT, STIM, and group within each cluster
prop_visit_stim_group_data <- consortium_data_visit_group %>%
  group_by(feature_based_ID_letter, VISIT, STIM, group) %>%
  summarize(
    visit_stim_group_cell_count = sum(cell_count),  # Sum of cell_count for each combination of VISIT, STIM, and group within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data_visit_group %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propVISITSTIMGROUPperCLUSTER = visit_stim_group_cell_count / nCluster  # Proportion of cells for each combination of VISIT, STIM, and group within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, VISIT, STIM, group, propVISITSTIMGROUPperCLUSTER)

# Merge the proportion data for VISIT, STIM, and group back into the consortium_data_visit_group dataframe
consortium_data_visit_group <- consortium_data_visit_group %>%
  left_join(prop_visit_stim_group_data, by = c("feature_based_ID_letter", "VISIT", "STIM", "group"))

# Calculate the proportion of cells for each combination of VISIT, STIM, and group within each cluster per PID
prop_visit_stim_group_pid_data <- consortium_data_split_celltype %>%
  group_by(feature_based_ID_letter, VISIT, STIM, group, PID) %>%
  summarize(
    visit_stim_group_cell_count = sum(cell_count),  # Sum of cell_count for each combination of VISIT, STIM, and group within each cluster
    .groups = "drop"
  ) %>%
  left_join(consortium_data_split_celltype %>% dplyr::select(feature_based_ID_letter, nCluster) %>% distinct(), by = "feature_based_ID_letter") %>%
  mutate(
    propVISITSTIMGROUPperCLUSTERperPID = visit_stim_group_pid_cell_count / nCluster  # Proportion of cells for each combination of VISIT, STIM, and group within each cluster
  ) %>%
  dplyr::select(feature_based_ID_letter, VISIT, STIM, group, propVISITSTIMGROUPperCLUSTERperPID)

# Merge the proportion data for VISIT, STIM, and group back into the consortium_data_split_celltype dataframe
consortium_data_split_celltype <- consortium_data_split_celltype %>%
  left_join(prop_visit_group_pid_data, by = c("feature_based_ID_letter", "VISIT", "STIM", "group", "PID"))

# Save consortium_data_split_celltype as a .csv file
write.csv(consortium_data_visit_group, paste0(dir_save, "consortium_data_visit_group.csv"), row.names = FALSE)
```

### Plot proportions of D0 vs D37 cells per cluster per PID #############################################

```{r}

```

##### ADD DOWNSAMPLING ################################################################################

### Overlay expression of ADTs on RNA clusters

```{r}
Idents(object = obj) <- "RNA_snn_res.0.6"

# Create a list of all cluster identities in obj
cluster.ids <- levels(Idents(obj))

# Initialize a list to store cluster markers
cluster.markers.RNAandADT <- list()

# Normalize the ADT data
DefaultAssay(obj) <- "ADT"
obj <- NormalizeData(obj, normalization.method = "CLR", margin = 2)

# Loop through each Seurat cluster in obj
for (cluster.id in cluster.ids) {
  
  # Find genes for RNA assay sorted by adjusted p value 
  genes_RNA <- FindMarkers(obj, ident.1 = cluster.id, assay = "RNA")
  genes_RNA <- rownames(genes_RNA[order(genes_RNA$p_val_adj), ])
  
  # Find genes for ADT assay sorted by adjusted p value 
  genes_ADT <- FindMarkers(obj, ident.1 = cluster.id, assay = "ADT")
  genes_ADT <- rownames(genes_ADT[order(genes_ADT$p_val_adj), ])
  
  # Find common genes between RNA and ADT assays
  cluster.markers.RNAandADT <- intersect(genes_RNA, genes_ADT)
  
  object.name <- paste0("cluster.markers.", cluster.id)

  # Plot violin plots of relative expression 
  DefaultAssay(obj) <- "RNA"
  vln_RNA <- VlnPlot(obj,
                      features = c(cluster.markers.RNAandADT)[1:10],
                      log = TRUE,
                      ncol = 1,
                      pt.size = 0) 
  main_title <- ggdraw() + 
  draw_label(paste0("RNA Cluster ", cluster.id), fontface = "bold", size = 14, hjust = 0.5)
  vln_RNA <- plot_grid(main_title, vln_RNA, nrow = 2, rel_heights = c(0.05, 0.95))


  DefaultAssay(obj) <- "ADT"
  vln_ADT <- VlnPlot(obj,
                      features = c(cluster.markers.RNAandADT)[1:10],
                      log = TRUE,
                      ncol = 1,
                      pt.size = 0)
  main_title <- ggdraw() + 
  draw_label(paste0("ADT Cluster ", cluster.id), fontface = "bold", size = 14, hjust = 0.5)
  vln_ADT <- plot_grid(main_title, vln_ADT, nrow = 2, rel_heights = c(0.05, 0.95))
  
  vln_plots <- paste0("Multimodal_DEG_VlnPlotRelExp_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, vln_plots), height = 30, width = 10)
  print(vln_RNA | vln_ADT)
  dev.off()
  
  # Plot feature plots overlaid onto UMAP
  
  DefaultAssay(obj) <- "RNA"
  feature_RNA <- FeaturePlot(obj,
                              features = c(cluster.markers.RNAandADT)[1:10],
                              label = TRUE,
                              label.size = 4,
                              ncol = 1,
                              pt.size = 0)
  main_title <- ggdraw() + 
  draw_label(paste0("RNA Cluster ", cluster.id), fontface = "bold", size = 14, hjust = 0.5)
  feature_RNA <- plot_grid(main_title, feature_RNA, nrow = 2, rel_heights = c(0.05, 0.95))
  
  DefaultAssay(obj) <- "ADT"
  feature_ADT <- FeaturePlot(obj,
                              features = c(cluster.markers.RNAandADT)[1:10],
                              label = TRUE,
                              label.size = 4,
                              ncol = 1,
                              pt.size = 0)
  main_title <- ggdraw() + 
  draw_label(paste0("ADT Cluster ", cluster.id), fontface = "bold", size = 14, hjust = 0.5)
  feature_ADT <- plot_grid(main_title, feature_ADT, nrow = 2, rel_heights = c(0.05, 0.95))
  
  feature_plots <- paste0("Multimodal_DEG_FeaturePlot_Top10_", object.name, ".pdf")
  pdf(paste0(dir_save, feature_plots), height = 30, width = 10)
  print(feature_RNA | feature_ADT)
  dev.off()
}
```

```{r}
save(obj, file = paste0(dir_save, "Seurat_ClusterIDCellsRNAonly_obj.Rdata"))
saveRDS(obj, file = paste0(dir_save, "Seurat_ClusterIDCellsRNAonly_obj.rds"))
```

## ADT (Protein) ######## SEPARATE THIS OUT INTO ITS OWN QMD

### Split the object into multiple layers for integration based on the ADT Assay

Integration is performed to account for batch effects. Therefore, the factor used to split the object into multiple layers should be the factor that provides information on which batch the samples came from. In this case, each batch has a unique RUN ID. The metadata column for that contains the RUN IDs is called "RUN" and should be used to integrate layers.

```{r}
DefaultAssay(obj) <- "ADT"
```

### Split the object into multiple layers for integration based on ADT Assay

```{r, warning = FALSE}
obj[["ADT"]] <- split(obj[["ADT"]], f = obj$RUN)
obj
```

### Normalize the ADT data

For the ADT assay we use Seurat NormalizeData function to perform CLR normalization with a margin of 2.

```{r, message = FALSE}
obj <- NormalizeData(obj, normalization.method = "CLR", margin = 2)
```

### Identify variable features

We allow all 165 ADTs as variable features for downstream analyses using the standard Seurat FindVariableFeatures function with selection method "vst".

```{r, message = FALSE}
obj <- FindVariableFeatures(obj, selection.method = "vst", nfeatures = 165)

# Identify the 10 most highly variable genes
top10.adt <- head(VariableFeatures(obj), 10)

# plot variable features and label top 10 variable features
plot1 <- VariableFeaturePlot(obj)
plot2 <-LabelPoints(plot = plot1, points = top10.adt, repel = TRUE)
```

```{r, echo = FALSE, warning = FALSE}
print(plot2)
```

### Scale the ADT data

Data is scaled using only variable features by default.

```{r}
obj <- ScaleData(obj)
```

### Perform linear dimensional reduction

Principal component analysis (PCA) is used for linear dimensional reduction of scaled data. PCA is run with default options. The plots below visualize dimensional reduction genes for principal components (PC) 1 and 2, display cell positioning in 2D, and a heatmap of genes associated with the top 1 and 15 PCs for all cells.

```{r, output = FALSE}
# Perform PCA for linear dimensional reduction on scaled data. Give reduction a new name to avoid overwriting RNA reduction. 
obj <- RunPCA(obj, features = NULL, reduction.name = 'pca.adt') 

# Examine and visualize PCA results a few different ways

plot1 <- VizDimLoadings(obj, dims = 1:2, reduction = "pca.adt")

plot2 <- DimPlot(obj, reduction = "pca.adt") + NoLegend()

plot3 <- DimHeatmap(obj, reduction = "pca.adt", dims = 1, cells = 500, balanced = TRUE)

plot4 <- DimHeatmap(obj, reduction = "pca.adt", dims = 1:6, cells = 500, balanced = TRUE)
```

```{r, echo = FALSE}
print(plot1)
print(plot2)
DimHeatmap(obj, reduction = "pca.adt", dims = 1, cells = 500, balanced = TRUE)
```

```{r, echo = FALSE}
#| fig-height: 13
DimHeatmap(obj, reduction = "pca.adt", dims = 1:6, cells = 500, balanced = TRUE)
```

### Examine variance explained by each principal component

Here we look at the variance in the dataset that is explained by each individual PC and at the cumulative variance explained by the PCs.

We also determine the dimensionality of the dataset using an Elbow plot (more efficient alternative to JackStraw procedure).

```{r}
pca = obj[["pca.adt"]]

# Get the eigenvalues
evs = pca@stdev^2
total.var = pca@misc$total.variance
varExplained = evs/total.var
pca.data = data.frame(PC=factor(1:length(evs)),
                      percVar=varExplained*100)
pca.data$cumulVar = cumsum(pca.data$percVar)

head(pca.data, 20)

scPlot1 <- pca.data[1:10,] %>%
          ggplot(aes(x=PC, y=percVar)) +
          geom_bar(stat='identity') +
          geom_hline(yintercept = 1, colour="red", linetype=3) +
          labs(title="Variance Explanation by PCA") +
          xlab("Principal Components") +
          ylab("Percentage of Explained Variance") +
          theme_bw()

scPlot2 <- pca.data[1:10,] %>%
          ggplot(aes(x=PC, y=cumulVar)) +
          geom_bar(stat='identity') +
          geom_hline(yintercept = 50, colour="red", linetype=3) +
          labs(title="Cumulative Variance Explanation by PCA") +
          xlab("Principal Components") +
          ylab("Cumulative Percentage of Explained Variance") +
          theme_bw()

elbow <- ElbowPlot(obj)
```

```{r, echo = FALSE}
print(scPlot1)
print(scPlot2)
print(elbow)
```

### Cluster cells based on ADT

Start with standard Seurat clustering method WITHOUT INTEGRATION. Use the bar and Elbow plots to determine minimum dimensions to use for clustering. Clustering is performed using UMAP for non-linear dimensional reduction. The number of dimensions is set to 30. PCA is used to find neighbors and clusters and for UMAP reduction.

The tabulated plots visualize the basic UMAP with seurat clusters for all cells and conditions as well as UMAPs grouped by metadata features and split by group.

```{r, message=FALSE}
obj <- FindNeighbors(obj, reduction = "pca.adt") 
obj <- FindClusters(obj, cluster.name = "unintegrated_clusters_adt") 
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca.adt", reduction.name = "umap.unintegrated.adt")

plot1 <- DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("seurat_clusters"), split.by = "group")
plot2 <- DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("RUN", "seurat_clusters"), split.by = "group")
plot3 <- DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("STIM", "seurat_clusters"), split.by = "group")
plot4 <- DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("PID", "seurat_clusters"), split.by = "group")
plot5 <- DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("VISIT", "seurat_clusters"), split.by = "group")
plot6 <- DimPlot(obj, reduction = "umap.unintegrated.adt", group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

::: panel-tabset
## UMAP group

```{r, echo = FALSE}
print(plot1)
```

## UMAP RUN

```{r, echo = FALSE}
#| fig-height: 10
print(plot2)
```

## UMAP STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot3)
```

## UMAP PID

```{r, echo = FALSE}
#| fig-height: 10
print(plot4)
```

## UMAP VISIT

```{r, echo = FALSE}
#| fig-height: 10
print(plot5)
```

## UMAP VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10
print(plot6)
```
:::

### Inspect cluster proportions on unintegrated clusters

Next we examine the proportion of each cluster that is comprised of cells with key metadata features: RUN, group, STIM, PID, and VISIT. Proportions are shown alongside total cell number per cluster.

```{r, warning = FALSE, message = FALSE}
plot_integrated_clusters = function (srat, batchcolumn) {
  ## take an integrated Seurat object, plot distributions over orig.ident

  count_table <- table(srat@meta.data$seurat_clusters, srat@meta.data[[batchcolumn]])
  count_mtx   <- as.data.frame.matrix(count_table)
  count_mtx$cluster <- rownames(count_mtx)
  melt_mtx    <- melt(count_mtx)
  melt_mtx$cluster <- as.factor(melt_mtx$cluster)

  cluster_size   <- aggregate(value ~ cluster, data = melt_mtx, FUN = sum)

  sorted_labels <- paste(sort(as.integer(levels(cluster_size$cluster)),decreasing = T))
  cluster_size$cluster <- factor(cluster_size$cluster,levels = sorted_labels)
  melt_mtx$cluster <- factor(melt_mtx$cluster,levels = sorted_labels)

  colnames(melt_mtx)[2] <- "dataset"


  p1 <- ggplot(cluster_size, aes(y= cluster,x = value)) + geom_bar(position="dodge", stat="identity",fill = "grey60") +
    theme_bw() + scale_x_log10() + xlab("Cells per cluster, log10 scale") + ylab("")
  p2 <- ggplot(melt_mtx,aes(x=cluster,y=value,fill=dataset)) +
    geom_bar(position="fill", stat="identity") + theme_bw() + coord_flip() +
    #scale_fill_brewer(palette = "Set2") +
    ylab("Fraction of cells in each dataset") + xlab("Cluster number") + theme(legend.position="top")

  p2 + p1 + plot_layout(widths = c(3,1))
}


plot1 <- plot_integrated_clusters(obj, 'group')
plot2 <- plot_integrated_clusters(obj, 'RUN')
plot3 <- plot_integrated_clusters(obj, 'STIM')
plot4 <- plot_integrated_clusters(obj, 'PID')
plot5 <- plot_integrated_clusters(obj, 'VISIT')
plot6 <- plot_integrated_clusters(obj, 'VISIT_STIM')
```

::: panel-tabset
## Proportions group

```{r, echo = FALSE}
print(plot1)
```

## Proportions RUN

```{r, echo = FALSE}
print(plot2)
```

## Proportions STIM

```{r, echo = FALSE}
print(plot3)
```

## Proportions PID

```{r, echo = FALSE}
print(plot4)
```

## Proportions VISIT

```{r, echo = FALSE}
print(plot5)
```

## Proportions VISIT & STIM

```{r, echo = FALSE}
print(plot6)
```
:::

### Perform integration of ADT Assay

Integration is performed using the RUN metadata variable. Each RUN is representative of a single experimental processing batch which includes samples from two PIDs at both time points. Each RUN therefore can be seen as an individual batch and can be used in integration to adjust for experimentally-introduced batch effects.

```{r}
obj <- IntegrateLayers(object = obj, 
                       method = CCAIntegration, 
                       orig.reduction = "pca.adt", 
                       new.reduction = "integrated.cca.adt", 
                       verbose = FALSE)

obj[["ADT"]] <- JoinLayers(obj[["ADT"]])

obj <- FindNeighbors(obj, reduction = "integrated.cca.adt", dims = 1:30) 
obj <- FindClusters(obj, resolution = 1.2)

obj <- RunUMAP(obj, dims = 1:30, reduction = "integrated.cca.adt", reduction.name = "umap.adt") 

plot1 <- DimPlot(obj, reduction = "umap.adt", group.by = c("seurat_clusters"), split.by = "group")
plot2 <- DimPlot(obj, reduction = "umap.adt", group.by = c("RUN", "seurat_clusters"), split.by = "group")
plot3 <- DimPlot(obj, reduction = "umap.adt", group.by = c("STIM", "seurat_clusters"), split.by = "group")
plot4 <- DimPlot(obj, reduction = "umap.adt", group.by = c("PID", "seurat_clusters"), split.by = "group")
plot5 <- DimPlot(obj, reduction = "umap.adt", group.by = c("VISIT", "seurat_clusters"), split.by = "group")
plot6 <- DimPlot(obj, reduction = "umap.adt", group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

::: panel-tabset
## UMAP group

```{r, echo = FALSE}
print(plot1)
```

## UMAP RUN

```{r, echo = FALSE}
#| fig-height: 10

print(plot2)
```

## UMAP STIM

```{r, echo = FALSE}
#| fig-height: 10

print(plot3)
```

## UMAP PID

```{r, echo = FALSE}
#| fig-height: 10

print(plot4)
```

## UMAP VISIT

```{r, echo = FALSE}
#| fig-height: 10

print(plot5)
```

## UMAP VISIT & STIM

```{r, echo = FALSE}
#| fig-height: 10

print(plot6)
```
:::

### Inspect RUN metrics on integrated clusters

Now that integration is complete, we will re-examine the proportion of each cluster that is comprised of cells with key metadata features: RUN, group, PID, VISIT, and STIM. Proportions are shown alongside total cell number per cluster. Compare these outputs to those above for unintegrated clusters to determine how cluster composition was changed by integration.

```{r}
plot1 <- plot_integrated_clusters(obj, 'group')
plot2 <- plot_integrated_clusters(obj, 'RUN')
plot3 <- plot_integrated_clusters(obj, 'STIM')
plot4 <- plot_integrated_clusters(obj, 'PID')
plot5 <- plot_integrated_clusters(obj, 'VISIT')
plot6 <- plot_integrated_clusters(obj, 'VISIT_STIM')
```

::: panel-tabset
## Proportions group

```{r, echo = FALSE}
print(plot1)
```

## Proportions RUN

```{r, echo = FALSE}
print(plot2)
```

## Proportions STIM

```{r, echo = FALSE}
print(plot3)
```

## Proportions PID

```{r, echo = FALSE}
print(plot4)
```

## Proportions VISIT

```{r, echo = FALSE}
print(plot5)
```

## Proportions VISIT & STIM

```{r, echo = FALSE}
print(plot6)
```
:::

### Determine more accurate cluster resolution using clustree

Iterating through different resolutions using the clustree package can help determine what resolution best fits the data so that it can be used for downstream analyses. Using clustree, we iterate the clustering algorithm over a resolution range of 0.2 - 2, increasing by 0.2 with each round. We then plot the UMAPs for a representative selection of these iterations to determine what resolution to select moving forward.

```{r, message=FALSE, output = FALSE}
#| fig-height: 13

resolution.range <- seq(from =0.2, to = 2, by = 0.2)
obj <- Seurat::FindClusters(object = obj, resolution = resolution.range)

clustree <- clustree(obj, prefix = "ADT_snn_res.")

pdf(paste0(dir_save, "clustree.all_adt.pdf"))
clustree_plot <- clustree
print(clustree_plot)
invisible(dev.off())

umap.0.4.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.0.4")
umap.0.6.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.0.6")
umap.0.8.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.0.8")
umap.1.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.1")
umap.1.2.adt <- DimPlot(obj, reduction = "umap.adt", label = T, group.by = "ADT_snn_res.1.2")

snn_all.adt <- (umap.0.4.adt | umap.0.6.adt) / (umap.0.8.adt | umap.1.adt) / umap.1.2.adt

pdf(paste0(dir_save, "umap_snn_compare_adt.pdf"), width = 20, height = 20)
snn_all.adt
invisible(dev.off())
```

```{r, echo = FALSE}
#| fig-height: 13

print(snn_all.adt)
```

### Visualize clusters

Based on the clustree analysis, the optimal resolution for this dataset is 1.2.We set cluster identities to those associated with resolution = 1.2 and use these identities for further analysis.

```{r, message=FALSE}
# Select which resolution to use based on clustree analysis and assign optimal cluster IDs to Idents
Idents(object = obj) <- "ADT_snn_res.0.6"

# Plot UMAP
pdf(paste0(dir_save, "umap_res.clustree_adt.pdf"))
plot1 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 6)
print(plot1)
invisible(dev.off())

# Plot Feature plot to ensure clustering is not driven by QC artifacts
pdf(paste0(dir_save, "umap_res.clustree_adt_QC.pdf"))
QC_feature <- FeaturePlot(obj, features = c("nCount_RNA", "nFeature_RNA", "percent.mito", "Complexity"))
print(QC_feature)
invisible(dev.off())
```

```{r, echo = FALSE}
print(plot1)
print(QC_feature)
```

To explore how clustering differs for various metadata features, we plot the optimized UMAP and group and split by features of interest.

```{r}
pdf(paste0(dir_save, "umap_allRUN_res.clustree_adt.pdf"), height = 6, width = 25)
plot1 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "RUN",
        repel = T,
        ncol = 2)
print(plot1)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allHIVES_res.clustree_adt.pdf"), height = 6, width = 25)
plot2 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "HIVE",
        repel = T,
        ncol = 2)
print(plot2)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allPID_res.clustree_adt.pdf"), height = 6, width = 25)
plot3 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "PID",
        repel = T,
        ncol = 2)
print(plot3)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allSTIM_res.clustree_adt.pdf"), height = 6, width = 20)
plot4 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "STIM",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot4)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allVISIT_res.clustree_adt.pdf"), height = 6, width = 20)
plot5 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = "group",
        split.by = "VISIT",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot5)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allConditions_res.clustree_adt.pdf"), height = 6, width = 20)
plot6 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = c("group", "STIM"),
        split.by = "VISIT",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot6)
invisible(dev.off())

pdf(paste0(dir_save, "umap_allConditionsAlternative_res.clustree_adt.pdf"), height = 6, width = 20)
plot7 <- DimPlot(obj,
        reduction = "umap.adt",
        label = TRUE,
        label.size = 4,
        group.by = c("VISIT", "STIM"),
        split.by = "group",
        repel = T,
        pt.size = 1,
        alpha = 0.8,
        raster = F)
print(plot7)
invisible(dev.off())
```

::: panel-tabset
## RUN

```{r, echo = FALSE}
#| fig-height: 19

print(plot1)
```

## HIVEs

```{r, echo = FALSE}
#| fig-height: 19

print(plot2)
```

## PID

```{r, echo = FALSE}
#| fig-height: 32

print(plot3)
```

## STIM

```{r, echo = FALSE}
print(plot4)
```

## VISIT

```{r, echo = FALSE}
print(plot5)
```

## PID & VISIT

```{r, echo = FALSE}
#| fig-height: 9.5

print(plot6)
```

## PID & VISIT Alternative

```{r, echo = FALSE}
#| fig-height: 9.5

print(plot7)
```
:::

### Determine marker expression by cluster

Find markers for every cell cluster compared to all remaining cells, report only the positive ones. Save a .csv file that contains the markers for each cluster.

```{r, message=FALSE}
obj.markers.adt <- FindAllMarkers(obj, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)

obj.markers.adt %>%
  group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1)

write.csv(obj.markers.adt, file = file.path(dir_save, "all_markers_snn0.6_adt.csv"), quote = FALSE)
```

### Examine differential expression in clusters

Identify markers differentially expressed between specific clusters of interest and plot differentially expressed features as relative expression and as counts.

cluster.ids.adt \<- levels(Idents(obj)) for (cluster.id in cluster.ids.adt) {

\# Find markers for the current cluster cluster.markers.adt \<- FindMarkers(obj, ident.1 = cluster.id) cluster.markers.adt vln_plot_relexp.adt \<- paste0("DEG_VlnPlotRelExp_Top10\_", object.name, "\_adt.pdf")

```{r, message=FALSE, warning = FALSE}
# Function to create relative expression violin plots 
create_vln_rel <- function(obj) {

  # Plot expression of top 10 differentially expressed genes for the current cluster
   vln_plot_rel <- VlnPlot(obj,
          features = rownames(cluster.markers.adt)[1:10],
          ncol = 2,
          pt.size = 0)
  vln_plot_relexp <- paste0("DEG_VlnPlotRelExp_Top10_", object.name, "_adt.pdf")
  pdf(paste0(dir_save, vln_plot_relexp), height = 12, width = 6)
  print(vln_plot_rel)
  dev.off()

  return(vln_plot_rel)

}

# Function to create counts violin plots
create_vln_cnt <- function(obj) {

  vln_plot_cnt <- VlnPlot(obj,
          features = rownames(cluster.markers.adt)[1:10],
          slot = "counts", 
          log = TRUE, 
          ncol = 2,
          pt.size = 0)
  vln_plot_counts <- paste0("DEG_VlnPlotCounts_Top10_", object.name, "_adt.pdf")
  pdf(paste0(dir_save, vln_plot_counts), height = 12, width = 6)
  print(vln_plot_cnt)
  dev.off()

  return(vln_plot_cnt)

}

# Function to create feature plots
create_feature <- function(obj) {

    feature_plot <- FeaturePlot(obj,
            features = rownames(cluster.markers.adt)[1:10], 
            label = TRUE,
            label.size = 4,
            split.by = "group",
            ncol = 2,
            pt.size = 0)
  feature_plots <- paste0("DEG_FeaturePlot_Top10_", object.name, "_adt.pdf")
  pdf(paste0(dir_save, feature_plots), height = 24, width = 6)
  print(feature_plot)
  dev.off()

  return(feature_plot)

}

# List to store relative expression violin plots
vln_plot_rel_list <- list()

# List to store counts violin plots
vln_plot_cnt_list <- list()

# List to store feature plots
feature_plot_list <- list()

# Create a list of all cluster identities in obj
cluster.ids.adt <- levels(Idents(obj))

# Initialize a list to store cluster markers
cluster.markers.adt <- list()

# Loop through each Seurat cluster in obj
for (cluster.id in cluster.ids.adt) {
  
  # Find markers for the current cluster
  cluster.markers.adt <- FindMarkers(obj, ident.1 = cluster.id)
  
  # Assign a dynamic object name based on the cluster ID
  object.name <- paste0("cluster.markers.", cluster.id)
  
  # Export cluster markers to a CSV file
  csv_file <- paste0(object.name, "_adt.csv")
  write.csv(cluster.markers.adt, file = file.path(dir_save, paste0(csv_file)), row.names = TRUE)
  
  # Create plots using functions
  vln_plot_rel <- create_vln_rel(obj)
  vln_plot_cnt <- create_vln_cnt(obj)
  feature_plot <- create_feature(obj)


  # Assign the plots to a variable with a dynamic name
  assign(paste0("VlnPlotRel_", cluster.id), vln_plot_rel)
  assign(paste0("VlnPlotCnt_", cluster.id), vln_plot_cnt)
  assign(paste0("FeaturePlot_", cluster.id), feature_plot)

  # Add the plots to the associated list
  vln_plot_rel_list[[cluster.id]] <- vln_plot_rel
  vln_plot_cnt_list[[cluster.id]] <- vln_plot_cnt
  feature_plot_list[[cluster.id]] <- feature_plot
  
}

# Plot a heatmap to look at the top 10 differentially expressed genes across all clusters
pdf(paste0(dir_save, "DEG_Heatmap_AllClusters_Top10_adt.pdf"), height = 30, width = 20)
obj.markers.adt %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC) -> top10
plot1 <- DoHeatmap(obj, features = top10$gene) + NoLegend()
invisible(dev.off())

# Find all markers distinguishing an interesting cluster from main PBMC clusters
InterestClustervOthers.markers.adt <- FindMarkers(obj, ident.1 = 4, ident.2 = c(0:3))
```

Plot top 10 differentially expressed genes per cluster as relative expression.

::: panel-tabset
```{r}
#| fig-height: 25.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(vln_plot_rel_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(vln_plot_rel_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Plot top 10 differentially expressed genes per cluster as counts.

::: panel-tabset
```{r}
#| fig-height: 25.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(vln_plot_cnt_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(vln_plot_cnt_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Plot top 10 differentially expressed genes per cluster as feature plots.

::: panel-tabset
```{r}
#| fig-height: 32.5
#| results: asis

# Generate the tabset in Quarto
for (cluster.id in names(feature_plot_list)) {
  cat(glue("## {cluster.id} \n\n"))
  print(feature_plot_list[[cluster.id]])
  cat("\n\n")
}
```
:::

Examine top 10 features that distinguish each cluster as a heatmap and print the top 10 markers that distinguish a cluster of interest from all others. In this case, we look at the markers that distinguish cluster 4 from all others.

```{r, echo = FALSE, warning = FALSE}
DoHeatmap(obj, features = top10$gene) + NoLegend()
head(InterestClustervOthers.markers.adt, n = 10)
```

### Assign cell types

Predict cell types based on expression using sc-Type

```{r, warning = FALSE}
# Load gene set preparation function 
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")

# Load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")
```

Prepare gene sets from input cell marker file. This uses the default of in-built cell marker DB.

```{r, warning = FALSE}
# DB file
#db_ <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";

db_ <- "data/ScTypeDB_full_CYedit6.xlsx"
tissue <- "Immune system" # e.g. Immune system, Pancreas, Liver, Eye, Kidney, Brain, Lung, Adrenal, Heart, Intestine, Muscle, Placenta, Spleen, Stomach, Thymus 

# prepare gene sets
gs_list <- gene_sets_prepare(db_, tissue)
```

Run sc-Type.

```{r, message = FALSE}

### CHANGE obj@meta.data$seurat_clusters TO Idents(obj)

# check Seurat object version (scRNA-seq matrix extracted differently in Seurat v4/v5)
seurat_package_v5 <- isFALSE('counts' %in% names(attributes(obj[["ADT"]])));
print(sprintf("Seurat object %s is used", ifelse(seurat_package_v5, "v5", "v4")))

# extract scaled scRNA-seq matrix
scRNAseqData_scaled.adt <- if (seurat_package_v5) as.matrix(obj[["ADT"]]$scale.data) else as.matrix(obj[["ADT"]]@scale.data)

# run ScType
es.max.adt <- sctype_score(scRNAseqData = scRNAseqData_scaled.adt, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# merge by cluster
cL_resutls.adt <- do.call("rbind", lapply(unique(obj@meta.data$seurat_clusters), function(cl){
  es.max.cl.adt = sort(rowSums(es.max.adt[ ,rownames(obj@meta.data[obj@meta.data$seurat_clusters==cl, ])]), decreasing = !0)
  head(data.frame(cluster = cl, type = names(es.max.cl.adt), scores = es.max.cl.adt, ncells = sum(obj@meta.data$seurat_clusters==cl)), 10)
}))
sctype_scores.adt <- cL_resutls.adt %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores.adt$type[as.numeric(as.character(sctype_scores.adt$scores)) < sctype_scores.adt$ncells/4] <- "Unknown"
print(sctype_scores.adt[,1:3])
```

Overlay cell type IDs on UMAP.

```{r}
obj@meta.data$sctype_classification.adt = NA
for(j in unique(sctype_scores.adt$cluster)){
  cl_type = sctype_scores.adt[sctype_scores.adt$cluster==j,]; 
  obj@meta.data$sctype_classification.adt[obj@meta.data$seurat_clusters == j] = as.character(cl_type$type[1])
}

pdf(paste0(dir_save, "umap_annotated_adt.pdf"), height = 7, width = 10)
umap_annotated_adt <- DimPlot(obj, reduction = "umap.adt", label = TRUE, repel = TRUE, group.by = 'sctype_classification.adt')
print(umap_annotated_adt)
invisible(dev.off())
umap_annotated_adt
```

```{r}
#| fig-height: 6.5

pdf(paste0(dir_save, "umap_annotated_splitgroup_adt.pdf"), height = 7, width = 15)
umap_annotated_adt_group <- DimPlot(obj, reduction = "umap.adt", split.by = "group", group.by = 'sctype_classification.adt')
print(umap_annotated_adt_group)
invisible(dev.off())
umap_annotated_adt_group
```

## Multimodal

### Identify multimodal neighbors

```{r}
obj <- FindMultiModalNeighbors(
  obj, reduction.list = list("pca", "pca.adt"), 
  dims.list = list(1:30, 1:18), modality.weight.name = "RNA.weight"
)
```

### Cluster and plot based on RNA and ADT assays

```{r}
obj <- RunUMAP(obj, nn.name = "weighted.nn", reduction.name = "wnn.umap", reduction.key = "wnnUMAP_")
obj <- FindClusters(obj, graph.name = "wsnn", algorithm = 3, resolution = 2, verbose = FALSE)

DimPlot(obj, reduction = 'wnn.umap', group.by = c("group", "seurat_clusters"))
```

```{r}
#| fig-height: 6.5

DimPlot(obj, reduction = 'wnn.umap', group.by = c("STIM", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = 'wnn.umap', group.by = c("PID", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = 'wnn.umap', group.by = c("VISIT", "seurat_clusters"), split.by = "group")
DimPlot(obj, reduction = 'wnn.umap', group.by = c("VISIT_STIM", "seurat_clusters"), split.by = "group")
```

### Overlay ADT expression over RNA-clustered UMAP.

```{r}

```

### Save Rdata and rds

```{r}
save(obj, file = paste0(dir_save, "Seurat_ClusterIDCells_obj.Rdata"))
saveRDS(obj, file = paste0(dir_save, "Seurat_ClusterIDcells_obj.rds"))
```
